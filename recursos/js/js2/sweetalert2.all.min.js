/*!
* alerta dulce2 v11.4.4
* Publicado bajo la licencia MIT.
*/
(función (global, fábrica) {
  typeof export === 'objeto' && typeof module !== 'indefinido' ? módulo.exportaciones = fábrica() :
  typeof define === 'función' && define.amd ? definir (fábrica):
  (global = global || self, global.Sweetalert2 = fábrica());
}(esto, función () { 'usar estricto';

  const consolePrefix = 'SweetAlert2:';
  /**
   * Filtrar los valores únicos en una nueva matriz
   * @param arr
   */

  const matrizúnica = arr => {
    resultado constante = [];

    for (sea i = 0; i < arr.longitud; i++) {
      if (resultado.indexOf(arr[i]) === -1) {
        resultado.push(arr[i]);
      }
    }

    resultado devuelto;
  };
  /**
   * Poner en mayúscula la primera letra de una cadena
   * @param {cadena} cadena
   * @returns {cadena}
   */

  const mayúsculaPrimeraLetra = str => str.charAt(0).toUpperCase() + str.slice(1);
  /**
   * @param {Lista de nodos | Colección HTML | NamedNodeMap} nodeList
   * @devoluciones {matriz}
   */

  const toArray = nodeList => Array.prototype.slice.call(nodeList);
  /**
   * Estandarizar las advertencias de la consola
   * @param {cadena | matriz} mensaje
   */

  const advertir = mensaje => {
    console.warn("".concat(consolePrefix, " ").concat(tipo de mensaje === 'objeto' ? mensaje.join(' ') : mensaje));
  };
  /**
   * Estandarizar errores de consola
   * @param {cadena} mensaje
   */

  const error = mensaje => {
    console.error("".concat(consolePrefix, " ").concat(mensaje));
  };
  /**
   * Estado global privado para `warnOnce`
   * @tipo {Array}
   * @privado
   */

  const previoWarnOnceMessages = [];
  /**
   * Mostrar una advertencia de consola, pero solo si aún no se ha mostrado
   * @param {cadena} mensaje
   */

  const advertirOnce = mensaje => {
    if (!previousWarnOnceMessages.includes(mensaje)) {
      anteriorWarnOnceMessages.push(mensaje);
      advertir (mensaje);
    }
  };
  /**
   * Mostrar una advertencia única en la consola sobre parámetros/métodos obsoletos
   */

  const warnAboutDeprecation = (deprecatedParam, useInstead) => {
    warnOnce("\"".concat(deprecatedParam, "\" está en desuso y se eliminará en la próxima versión importante. Utilice \"").concat(useInstead, "\" en su lugar."));
  };
  /**
   * Si `arg` es una función, llámela (sin argumentos ni contexto) y devuelva el resultado.
   * De lo contrario, simplemente pase el valor
   * @param argumento
   */

  const callIfFunction = arg => typeof arg === 'función' ? arg() : arg;
  const hasToPromiseFn = arg => arg && typeof arg.toPromise === 'función';
  const asPromise = arg => hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);
  const isPromise = arg => arg && Promise.resolve(arg) === arg;

  parámetros predeterminados const = {
    título: '',
    texto del título: '',
    texto: '',
    HTML: '',
    pie de página: '',
    icono: indefinido,
    iconColor: indefinido,
    iconHtml: indefinido,
    plantilla: indefinido,
    brindis: falso,
    mostrarClase: {
      ventana emergente: 'swal2-show',
      telón de fondo: 'swal2-backdrop-show',
      icono: 'swal2-icono-mostrar'
    },
    ocultarClase: {
      ventana emergente: 'swal2-hide',
      telón de fondo: 'swal2-backdrop-hide',
      icono: 'swal2-icono-ocultar'
    },
    clase personalizada: {},
    objetivo: 'cuerpo',
    color: indefinido,
    telón de fondo: cierto,
    alturaAuto: verdadero,
    allowOutsideClick: verdadero,
    allowEscapeKey: verdadero,
    permitirEnterKey: verdadero,
    stopKeydownPropagation: verdadero,
    keydownListenerCapture: falso,
    showConfirmButton: verdadero,
    showDenyButton: falso,
    showCancelButton: falso,
    preconfirmar: indefinido,
    predenegar: indefinido,
    confirmarButtonText: 'OK',
    confirmButtonAriaLabel: '',
    confirmButtonColor: indefinido,
    denyButtonText: 'No',
    denyButtonAriaLabel: '',
    denyButtonColor: indefinido,
    cancelButtonText: 'Cancelar',
    cancelButtonAriaLabel: '',
    cancelButtonColor: indefinido,
    botonesEstilismo: cierto,
    botones inversos: falso,
    focoConfirmar: verdadero,
    FocusDeny: falso,
    FocusCancel: falso,
    enfoque de retorno: verdadero,
    mostrarBotónCerrar: falso,
    closeButtonHtml: '&veces;',
    closeButtonAriaLabel: 'Cerrar este diálogo',
    cargadorHtml: '',
    showLoaderOnConfirm: falso,
    showLoaderOnDeny: falso,
    imageUrl: indefinido,
    ancho de imagen: indefinido,
    altura de la imagen: indefinido,
    imagenAlt: '',
    temporizador: indefinido,
    barra de progreso del temporizador: falso,
    ancho: indefinido,
    relleno: indefinido,
    fondo: indefinido,
    entrada: indefinido,
    marcador de posición de entrada: '',
    etiqueta de entrada: '',
    valor de entrada: '',
    opciones de entrada: {},
    entradaAutoTrim: verdadero,
    atributos de entrada: {},
    validador de entrada: indefinido,
    returnInputValueOnDeny: falso,
    mensaje de validación: indefinido,
    crecer: falso,
    posición: 'centro',
    Pasos de progreso: [],
    paso de progreso actual: indefinido,
    ProgresoPasosDistancia: indefinido,
    willOpen: indefinido,
    abrió: indefinido,
    renderizar: indefinido,
    cerrará: indefinido,
    hizoCerrar: indefinido,
    Destruyó: indefinido,
    relleno de la barra de desplazamiento: verdadero
  };
  const updatableParams = ['allowEscapeKey', 'allowOutsideClick', 'background', 'buttonsStyling', 'cancelButtonAriaLabel', 'cancelButtonColor', 'cancelButtonText', 'closeButtonAriaLabel', 'closeButtonHtml', 'color', 'confirmButtonAriaLabel', 'confirmButtonColor ', 'confirmButtonText', 'currentProgressStep', 'customClass', 'denyButtonAriaLabel', 'denyButtonColor', 'denyButtonText', 'didClose', 'didDestroy', 'footer', 'hideClass', 'html', 'icon', 'iconColor', 'iconHtml', 'imageAlt', 'imageHeight', 'imageUrl', 'imageWidth', 'preConfirm', 'preDeny', 'progressSteps', 'returnFocus','reverseButtons', 'showCancelButton', 'showCloseButton', 'showConfirmButton', 'showDenyButton', 'text', 'title', 'titleText', 'willClose'];
  const deprecatedParams = {};
  const toastIncompatibleParams = ['allowOutsideClick', 'allowEnterKey', 'backdrop', 'focusConfirm', 'focusDeny', 'focusCancel', 'returnFocus', 'heightAuto', 'keydownListenerCapture'];
  /**
   * Es un parámetro válido
   * @param {cadena} nombreParam
   */

  const isValidParameter = paramName => {
    devuelve Object.prototype.hasOwnProperty.call(defaultParams, paramName);
  };
  /**
   * Es un parámetro válido para el método Swal.update()
   * @param {cadena} nombreParam
   */

  const isUpdatableParameter = paramName => {
    devuelve updatetableParams.indexOf(paramName) !== -1;
  };
  /**
   * Es un parámetro obsoleto
   * @param {cadena} nombreParam
   */

  const isDeprecatedParameter = paramName => {
    return deprecatedParams[paramName];
  };

  const checkIfParamIsValid = param => {
    if (!isValidParameter(parámetro)) {
      warn("Parámetro desconocido \"".concat(parámetro, "\""));
    }
  };

  const checkIfToastParamIsValid = param => {
    if (toastIncompatibleParams.includes(parámetro)) {
      warn("El parámetro \"".concat(param, "\" es incompatible con los brindis"));
    }
  };

  const checkIfParamIsDeprecated = param => {
    if (isDeprecatedParameter(parámetro)) {
      warnAboutDeprecation(param, isDeprecatedParameter(param));
    }
  };
  /**
   * Mostrar advertencias relevantes para parámetros dados
   *
   * @param parámetros
   */


  const showWarningsForParams = params => {
    if (!params.backdrop && params.allowOutsideClick) {
      warn('El parámetro "allowOutsideClick" requiere que el parámetro `backdrop` se establezca en `true`');
    }

    para (const parámetro en parámetros) {
      checkIfParamIsValid(parámetro);

      if (parámetros.brindis) {
        checkIfToastParamIsValid(parámetro);
      }

      checkIfParamIsDeprecated(parámetro);
    }
  };

  const swalPrefix = 'swal2-';
  const prefijo = artículos => {
    resultado constante = {};

    para (const i en artículos) {
      resultado[elementos[i]] = swalPrefix + elementos[i];
    }

    resultado devuelto;
  };
  const swalClasses = prefix(['container', 'shown', 'height-auto', 'iosfix', 'popup', 'modal', 'no-backdrop', 'no-transition', 'toast', 'toast -mostrado', 'mostrar', 'ocultar', 'cerrar', 'título', 'contenedor html', 'acciones', 'confirmar', 'denegar', 'cancelar', 'esquema predeterminado', 'pie de página ', 'icono', 'contenido de icono', 'imagen', 'entrada', 'archivo', 'rango', 'seleccionar', 'radio', 'casilla de verificación', 'etiqueta', 'área de texto', 'error de entrada ', 'etiqueta de entrada', 'mensaje de validación', 'pasos de progreso', 'paso de progreso activo', 'paso de progreso', 'línea de paso de progreso', 'cargador', 'loading', 'styled', 'top', 'top-start', 'top-end', 'top-left', 'top-right', 'center', 'center-start', 'center-end' , 'centro-izquierda', 'centro-derecha', 'abajo', 'abajo-inicio', 'extremo inferior', 'abajo-izquierda', 'abajo-derecha', 'crecer-fila', 'crecer- column', 'grow-fullscreen', 'rtl', 'timer-progress-bar', 'timer-progress-bar-container', 'scrollbar-measure', 'icon-success', 'icon-warning', ' icon-info', 'icon-pregunta', 'icon-error']);'centro-derecha', 'abajo', 'abajo-inicio', 'extremo inferior', 'abajo-izquierda', 'abajo-derecha', 'fila de crecimiento', 'columna de crecimiento', 'pantalla completa de crecimiento ', 'rtl', 'timer-progress-bar', 'timer-progress-bar-container', 'scrollbar-measure', 'icon-success', 'icon-warning', 'icon-info', 'icon -pregunta', 'icono-error']);'centro-derecha', 'abajo', 'abajo-inicio', 'extremo inferior', 'abajo-izquierda', 'abajo-derecha', 'fila de crecimiento', 'columna de crecimiento', 'pantalla completa de crecimiento ', 'rtl', 'timer-progress-bar', 'timer-progress-bar-container', 'scrollbar-measure', 'icon-success', 'icon-warning', 'icon-info', 'icon -pregunta', 'icono-error']);icono-error']);icono-error']);
  const iconTypes = prefix(['éxito', 'advertencia', 'info', 'pregunta', 'error']);

  /**
   * Obtiene el contenedor emergente que contiene el telón de fondo y la propia ventana emergente.
   *
   * @devoluciones {HTMLElement | nulo}
   */

  const getContainer = () => document.body.querySelector(".".concat(swalClasses.container));
  const elementoPorSelector = selectorString => {
    const contenedor = getContainer();
    contenedor de retorno? container.querySelector(selectorString) : null;
  };

  const elementoPorClase = nombreClase => {
    return elementBySelector(".".concat(className));
  };

  const getPopup = () => elementByClass(swalClasses.popup);
  const getIcon = () => elementByClass(swalClasses.icon);
  const getTitle = () => elementByClass(swalClasses.title);
  const getHtmlContainer = () => elementByClass(swalClasses['html-container']);
  const getImage = () => elementByClass(swalClasses.image);
  const getProgressSteps = () => elementByClass(swalClasses['progress-steps']);
  const getValidationMessage = () => elementByClass(swalClasses['validation-message']);
  const getConfirmButton = () => elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.confirm));
  const getDenyButton = () => elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.deny));
  const getInputLabel = () => elementByClass(swalClasses['input-label']);
  const getLoader = () => elementBySelector(".".concat(swalClasses.loader));
  const getCancelButton = () => elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.cancel));
  const getActions = () => elementByClass(swalClasses.actions);
  const getFooter = () => elementByClass(swalClasses.footer);
  const getTimerProgressBar = () => elementByClass(swalClasses['timer-progress-bar']);
  const getCloseButton = () => elementByClass(swalClasses.close); // https://github.com/jkup/focusable/blob/master/index.js

  const enfocable = "\na[href],\n área[href],\n input:not([deshabilitado]),\n select:not([deshabilitado]),\n textarea:not([deshabilitado]), \n botón: no ([deshabilitado]),\n iframe,\n objeto,\n incrustar,\n [tabindex=\"0\"],\n [contenido editable],\n audio[controles],\n video[controles],\n resumen\n";
  const obtenerElementosEnfocables = () => {
    const focusableElementsWithTabindex = toArray(getPopup().querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])')) // ordenar según tabindex
    .sort((a, b) => {
      const tabindexA = parseInt(a.getAttribute('tabindex'));
      const tabindexB = parseInt(b.getAttribute('tabindex'));

      si (tabindexA > tabindexB) {
        devolver 1;
      } más si (tabindexA < tabindexB) {
        devolver -1;
      }

      devolver 0;
    });
    const otherFocusableElements = toArray(getPopup().querySelectorAll(focusable)).filter(el => el.getAttribute('tabindex') !== '-1');
    return uniqueArray(focusableElementsWithTabindex.concat(otherFocusableElements)).filter(el => isVisible(el));
  };
  const esModal = () => {
    return hasClass(document.body, swalClasses.shown) && !hasClass(document.body, swalClasses['toast-shown']) && !hasClass(document.body, swalClasses['no-backdrop']);
  };
  const esTostada = () => {
    return getPopup() && hasClass(getPopup(), swalClasses.toast);
  };
  const estáCargando = () => {
    return getPopup().hasAttribute('carga de datos');
  };

  estados constantes = {
    anteriorBodyPadding: nulo
  };
  /**
   * Establecer de forma segura el HTML interno de un elemento
   * https://github.com/sweetalert2/sweetalert2/issues/1926
   *
   * @param {HTMLElement} elemento
   * @param {cadena} html
   */

  const setInnerHtml = (elemento, html) => {
    elem.textContent = '';

    si (html) {
      const analizador = nuevo DOMParser();
      const analizado = analizador.parseFromString(html, "texto/html");
      toArray(parsed.querySelector('head').childNodes).forEach(child => {
        elem.appendChild(hijo);
      });
      toArray(analizado.querySelector('cuerpo').childNodes).forEach(child => {
        elem.appendChild(hijo);
      });
    }
  };
  /**
   * @param {HTMLElement} elemento
   * @param {cadena} nombre de clase
   * @devoluciones {booleano}
   */

  const hasClass = (elemento, className) => {
    if (! nombre de la clase) {
      falso retorno;
    }

    const classList = className.split(/\s+/);

    for (sea i = 0; i < classList.length; i++) {
      if (!elem.classList.contains(classList[i])) {
        falso retorno;
      }
    }

    devolver verdadero;
  };

  const removeCustomClasses = (elemento, parámetros) => {
    toArray(elem.classList).forEach(className => {
      if (!Object.values(swalClasses).includes(className) && !Object.values(iconTypes).includes(className) && !Object.values(params.showClass).includes(className)) {
        elem.classList.remove(nombreClase);
      }
    });
  };

  const applyCustomClass = (elem, params, className) => {
    removeCustomClasses(elemento, parámetros);

    if (params.customClass && params.customClass[className]) {
      if (typeof params.customClass[className] !== 'string' && !params.customClass[className].forEach) {
        return warn("Tipo no válido de customClass.".concat(className, "! Cadena esperada u objeto iterable, se obtuvo \"").concat(typeof params.customClass[className], "\""));
      }

      addClass(elem, params.customClass[className]);
    }
  };
  /**
   * Ventana emergente @param {HTMLElement}
   * @param {cadena} tipo de entrada
   * @devoluciones {HTMLInputElement | nulo}
   */

  const getInput = (ventana emergente, tipo de entrada) => {
    si (! tipo de entrada) {
      devolver nulo;
    }

    cambiar (tipo de entrada) {
      caso 'seleccionar':
      caso 'área de texto':
      expediente':
        return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses[inputType]));

      caso 'casilla de verificación':
        return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.checkbox, " input"));

      caso 'radio':
        return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.radio, " input:checked")) || popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.radio, " input:first-child"));

      caso 'rango':
        return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.range, " input"));

      por defecto:
        return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.input));
    }
  };
  /**
   * @param {HTMLInputElement} entrada
   */

  const focusInput = entrada => {
    entrada.focus(); // coloca el cursor al final del texto en la entrada de texto

    if (entrada.tipo !== 'archivo') {
      // http://stackoverflow.com/a/2345915
      const val = entrada.valor;
      entrada.valor = '';
      entrada.valor = val;
    }
  };
  /**
   * @param {ElementoHTML | Elemento HTML[] | objetivo nulo}
   * @param {cadena | cadena[]} lista de clases
   * @param {booleano} condición
   */

  const toggleClass = (objetivo, lista de clases, condición) => {
    if (!objetivo || !clasesLista) {
      regreso;
    }

    if (tipo de lista de clases === 'cadena') {
      classList = classList.split(/\s+/).filter(Booleano);
    }

    classList.forEach(className => {
      if (Array.isArray(objetivo)) {
        destino.paraCada(elemento => {
          condición? elem.classList.add(className) : elem.classList.remove(className);
        });
      } demás {
        condición? target.classList.add(className) : target.classList.remove(className);
      }
    });
  };
  /**
   * @param {ElementoHTML | Elemento HTML[] | objetivo nulo}
   * @param {cadena | cadena[]} lista de clases
   */

  const addClass = (objetivo, classList) => {
    toggleClass(objetivo, classList, true);
  };
  /**
   * @param {ElementoHTML | Elemento HTML[] | objetivo nulo}
   * @param {cadena | cadena[]} lista de clases
   */

  const removeClass = (objetivo, classList) => {
    toggleClass(objetivo, classList, false);
  };
  /**
   * Obtener hijo directo de un elemento por nombre de clase
   *
   * @param {HTMLElement} elemento
   * @param {cadena} nombre de clase
   * @devoluciones {HTMLElement | nulo}
   */

  const getDirectChildByClass = (elemento, className) => {
    const childNodes = toArray(elem.childNodes);

    for (sea i = 0; i < childNodes.length; i++) {
      if (hasClass(childNodes[i], className)) {
        return childNodes[i];
      }
    }
  };
  /**
   * @param {HTMLElement} elemento
   * Propiedad @param {cadena}
   * @param {*} valor
   */

  const applyNumericalStyle = (elemento, propiedad, valor) => {
    if (valor === "".concat(parseInt(valor))) {
      valor = parseInt(valor);
    }

    if (valor || parseInt(valor) === 0) {
      elem.style[propiedad] = tipo de valor === 'número' ? "".concat(valor, "px") : valor;
    } demás {
      elem.style.removeProperty(propiedad);
    }
  };
  /**
   * @param {HTMLElement} elemento
   * @param {cadena} pantalla
   */

  const mostrar = función (elemento) {
    let display = argumentos.longitud > 1 && argumentos[1] !== indefinido ? argumentos[1] : 'flex';
    elem.style.display = mostrar;
  };
  /**
   * @param {HTMLElement} elemento
   */

  const ocultar = elemento => {
    elem.style.display = 'ninguno';
  };
  const setStyle = (padre, selector, propiedad, valor) => {
    const el = parent.querySelector(selector);

    Me caí) {
      el.style[propiedad] = valor;
    }
  };
  const alternar = (elemento, condición, visualización) => {
    condición? mostrar(elemento, mostrar) : ocultar(elemento);
  }; // tomado de jquery $(elem).is(':visible') implementación

  const isVisible = elem => !!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));
  const allButtonsAreHidden = () => !isVisible(getConfirmButton()) && !isVisible(getDenyButton()) && !isVisible(getCancelButton());
  const isScrollable = elem => !!(elem.scrollHeight > elem.clientHeight); // tomado de https://stackoverflow.com/a/46352119

  const hasCssAnimation = elem => {
    const estilo = ventana.getComputedStyle(elem);
    const animDuration = parseFloat(style.getPropertyValue('animation-duration') || '0');
    const transDuration = parseFloat(style.getPropertyValue('transition-duration') || '0');
    return duraciónanimación > 0 || transDuración > 0;
  };
  const animateTimerProgressBar = función (temporizador) {
    let reset = argumentos.longitud > 1 && argumentos[1] !== indefinido ? argumentos[1] : falso;
    const timerProgressBar = getTimerProgressBar();

    if (isVisible(timerProgressBar)) {
      si (restablecer) {
        timerProgressBar.style.transition = 'ninguno';
        timerProgressBar.style.width = '100%';
      }

      establecerTiempo de espera(() => {
        timerProgressBar.style.transition = "ancho". concat (temporizador / 1000, "s lineal");
        timerProgressBar.style.width = '0%';
      }, 10);
    }
  };
  const stopTimerProgressBar = () => {
    const timerProgressBar = getTimerProgressBar();
    const timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
    timerProgressBar.style.removeProperty('transición');
    timerProgressBar.style.width = '100%';
    const timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
    const timerProgressBarPercent = timerProgressBarWidth / timerProgressBarFullWidth * 100;
    timerProgressBar.style.removeProperty('transición');
    timerProgressBar.style.width = "".concat(timerProgressBarPercent, "%");
  };

  /**
   * Detectar entorno de nodo
   *
   * @devoluciones {booleano}
   */
  const isNodeEnv = () => tipo de ventana === 'indefinido' || tipo de documento === 'indefinido';

  constante RESTORE_FOCUS_TIMEOUT = 100;

  const globalState = {};

  const focoPreviousActiveElement = () => {
    if (globalState.previousActiveElement && globalState.previousActiveElement.focus) {
      globalState.previousActiveElement.focus();
      globalState.previousActiveElement = nulo;
    } else if (documento.cuerpo) {
      documento.cuerpo.focus();
    }
  }; // Restaurar elemento activo anterior (enfocado)


  const restaurarElementoActivo = devolverEnfoque => {
    devolver nueva promesa (resolver => {
      si (!returnFocus) {
        volver resolver();
      }

      const x = ventana.scrollX;
      const y = ventana.scrollY;
      globalState.restoreFocusTimeout = establecerTiempo de espera (() => {
        focoElementoActivoAnterior();
        resolver();
      }, RESTORE_FOCUS_TIMEOUT); // problemas/900

      ventana.scrollTo(x, y);
    });
  };

  const sweetHTML = "\n <div aria-labelledby=\"".concat(swalClasses.title, "\" aria-describedby=\"").concat(swalClasses['html-container'], "\" class= \"").concat(swalClasses.popup, "\" tabindex=\"-1\">\n <button type=\"button\" class=\"").concat(swalClasses.close, "\" ></button>\n <ul class=\"").concat(swalClasses['progress-steps'], "\"></ul>\n <div class=\"").concat(swalClasses. icono, "\"></div>\n <img class=\"").concat(swalClasses.image, "\" />\n <h2 class=\"").concat(swalClasses.title, " \" id=\"").concat(swalClasses.title, "\"></h2>\n <div clase=\"").concat(swalClasses['html-container'], "\" id=\"").concat(swalClasses['html-container'], "\"></div>\n <input class=\ "").concat(swalClasses.input, "\" />\n <tipo de entrada=\"archivo\" class=\"").concat(swalClasses.file, "\" />\n <div class= \"").concat(swalClasses.range, "\">\n <input type=\"range\" />\n <output></output>\n </div>\n <select class=\ "").concat(swalClasses.select, "\"></select>\n <div class=\"").concat(swalClasses.radio, "\"></div>\n <etiqueta para=\ "").concat(swalClasses.checkbox, "\" class=\"").concat(swalClasses.checkbox, "\">\n <input type=\"checkbox\" />\n <span class=\"").concat(swalClasses.label, "\"></span>\n </label>\n <textarea class= \"").concat(swalClasses.textarea, "\"></textarea>\n <div class=\"").concat(swalClasses['validation-message'], "\" id=\"") .concat(swalClasses['validation-message'], "\"></div>\n <div class=\"").concat(swalClasses.actions, "\">\n <div class=\"" ).concat(swalClasses.loader, "\"></div>\n <tipo de botón=\"botón\" class=\"").concat(swalClasses.confirm, "\"></button>\n <tipo de botón=\"botón\" clase=\"").concat(swalClasses.deny, "\"></botón>\n <tipo de botón=\"botón\" clase=\"").concat(swalClasses.cancel, "\"></botón>\n </div>\n <div clase=\ "").concat(swalClasses.footer, "\"></div>\n <div class=\"").concat(swalClasses['timer-progress-bar-container'], "\">\n <div class=\"").concat(swalClasses['timer-progress-bar'], "\"></div>\n </div>\n </div>\n").replace(/ (^|\n)\s*/g, '');contenedor-barra-de-progreso-temporizador'], "\">\n <div class=\"").concat(swalClasses['barra-de-progreso-temporizador'], "\"></div>\n </ div>\n </div>\n").replace(/(^|\n)\s*/g, '');contenedor-barra-de-progreso-temporizador'], "\">\n <div class=\"").concat(swalClasses['barra-de-progreso-temporizador'], "\"></div>\n </ div>\n </div>\n").replace(/(^|\n)\s*/g, '');

  const resetOldContainer = () => {
    const contenedorAntiguo = obtenerContenedor();

    if (!antiguoContenedor) {
      falso retorno;
    }

    ContenedorAntiguo.remove();
    removeClass([document.documentElement, document.body], [swalClasses['no-backdrop'], swalClasses['toast-shown'], swalClasses['has-column']]);
    devolver verdadero;
  };

  const resetValidationMessage = () => {
    globalState.currentInstance.resetValidationMessage();
  };

  const agregarInputChangeListeners = () => {
    const ventana emergente = getPopup();
    const input = getDirectChildByClass(popup, swalClasses.input);
    const archivo = getDirectChildByClass(popup, swalClasses.file);
    const range = popup.querySelector(".".concat(swalClasses.range, " input "));
    const rangeOutput = popup.querySelector(".".concat(swalClasses.range, "output"));
    const select = getDirectChildByClass(popup, swalClasses.select);
    const casilla de verificación = popup.querySelector(".".concat(swalClasses.checkbox, "entrada"));
    const textarea = getDirectChildByClass(popup, swalClasses.textarea);
    entrada.oninput = resetValidationMessage;
    archivo.onchange = resetValidationMessage;
    select.onchange = resetValidationMessage;
    checkbox.onchange = resetValidationMessage;
    textarea.oninput = resetValidationMessage;

    rango.oninput = () => {
      resetValidationMessage();
      rangoSalida.valor = rango.valor;
    };

    rango.onchange = () => {
      resetValidationMessage();
      rango.siguienteHermano.valor = rango.valor;
    };
  };

  const getTarget = objetivo => tipo de objetivo === 'cadena' ? document.querySelector(objetivo) : objetivo;

  const configuraciónAccesibilidad = params => {
    const ventana emergente = getPopup();
    popup.setAttribute('rol', params.toast ? 'alerta' : 'diálogo');
    popup.setAttribute('aria-live', params.toast ? 'educado' : 'asertivo');

    if (!params.brindis) {
      popup.setAttribute('aria-modal', 'true');
    }
  };

  const setupRTL = targetElement => {
    if (ventana.getComputedStyle(objetivoElemento).dirección === 'rtl') {
      addClass(getContainer(), swalClasses.rtl);
    }
  };
  /*
   * Agregar modal + telón de fondo a DOM
   */


  const init = parámetros => {
    // Limpiar el antiguo contenedor emergente si existe
    const oldContainerExisted = resetOldContainer();
    /* estambul ignorar si */

    if (esEnvNodo()) {
      error('SweetAlert2 requiere documento para inicializar');
      regreso;
    }

    contenedor const = document.createElement('div');
    container.className = swalClasses.container;

    si (antiguoContenedorExistía) {
      addClass(contenedor, swalClasses['sin transición']);
    }

    setInnerHtml(contenedor, dulceHTML);
    const targetElement = getTarget(params.target);
    targetElement.appendChild(contenedor);
    setupAccessibility(parámetros);
    setupRTL(elementoobjetivo);
    addInputChangeListeners();
  };

  /**
   * @param {ElementoHTML | objeto | cadena} parámetro
   * @param {HTMLElement} objetivo
   */

  const parseHtmlToContainer = (parámetro, destino) => {
    // elemento DOM
    if (param instancia de HTMLElement) {
      target.appendChild(parámetro);
    } // Objeto
    else if (typeof param === 'objeto') {
      handleObject(parámetro, destino);
    } // Cadena simple
    más si (parámetro) {
      setInnerHtml(objetivo, parámetro);
    }
  };
  /**
   * @param {objeto} parámetro
   * @param {HTMLElement} objetivo
   */

  const handleObject = (parámetro, objetivo) => {
    // elemento(s) JQuery
    si (parámetro.jquery) {
      handleJqueryElem(objetivo, parámetro);
    } // Para otros objetos usa su representación de cadena
    demás {
      setInnerHtml(objetivo, param.toString());
    }
  };

  const handleJqueryElem = (objetivo, elemento) => {
    destino.textContent = '';

    si (0 en elemento) {
      para (sea i = 0; (i en elem); i++) {
        target.appendChild(elem[i].cloneNode(true));
      }
    } demás {
      target.appendChild(elem.cloneNode(true));
    }
  };

  const animaciónEndEvent = (() => {
    // Impedir la ejecución en Node env

    /* estambul ignorar si */
    if (esEnvNodo()) {
      falso retorno;
    }

    const testEl = documento.createElement('div');
    const transEndEventNames = {
      WebkitAnimation: 'webkitAnimationEnd',
      // Chrome, Safari y Ópera
      animation: 'animationend' // Sintaxis estándar

    };

    for (const i en transEndEventNames) {
      if (Object.prototype.hasOwnProperty.call(transEndEventNames, i) && typeof testEl.style[i] !== 'indefinido') {
        volver transEndEventNames[i];
      }
    }

    falso retorno;
  })();

  // https://github.com/twbs/bootstrap/blob/master/js/src/modal.js

  const medidaScrollbar = () => {
    const scrollDiv = documento.createElement('div');
    scrollDiv.className = swalClasses['scrollbar-measure'];
    documento.cuerpo.appendChild(scrollDiv);
    const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
    documento.cuerpo.removeChild(scrollDiv);
    volver ancho de la barra de desplazamiento;
  };

  const renderActions = (instancia, parámetros) => {
    const acciones = getActions();
    const cargador = getLoader(); // Envoltura de acciones (botones)

    if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {
      ocultar (acciones);
    } demás {
      mostrar(acciones);
    } // Clase personalizada


    applyCustomClass(acciones, parámetros, 'acciones'); // Renderizar todos los botones

    renderButtons(acciones, cargador, parámetros); // cargador

    setInnerHtml(cargador, params.loaderHtml);
    applyCustomClass(cargador, parámetros, 'cargador');
  };

  función renderButtons (acciones, cargador, parámetros) {
    const confirmButton = getConfirmButton();
    const denyButton = getDenyButton();
    const cancelButton = getCancelButton(); // Botones de procesamiento

    renderButton(confirmarBoton, 'confirmar', params);
    renderButton(denyButton, 'denegar', parámetros);
    renderButton(cancelButton, 'cancelar', parámetros);
    handleButtonsStyling(confirmButton, denyButton, cancelButton, params);

    if (parámetros.reverseButtons) {
      if (parámetros.brindis) {
        acciones.insertBefore(cancelButton, confirmButton);
        acciones.insertBefore(denyButton, confirmButton);
      } demás {
        acciones.insertBefore(cancelButton, cargador);
        acciones.insertBefore(denyButton, cargador);
        acciones.insertBefore(confirmButton, cargador);
      }
    }
  }

  function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {
    if (!params.buttonsStyling) {
      return removeClass([confirmButton, denyButton, cancelButton], swalClasses.styled);
    }

    addClass([confirmButton, denyButton, cancelButton], swalClasses.styled); // Colores de fondo de los botones

    if (params.confirmButtonColor) {
      confirmButton.style.backgroundColor = params.confirmButtonColor;
      addClass(confirmButton, swalClasses['default-outline']);
    }

    if (parámetros.denyButtonColor) {
      denyButton.style.backgroundColor = params.denyButtonColor;
      addClass(denyButton, swalClasses['default-outline']);
    }

    if (parámetros.cancelButtonColor) {
      cancelButton.style.backgroundColor = params.cancelButtonColor;
      addClass(cancelButton, swalClasses['default-outline']);
    }
  }

  función renderButton (botón, tipo de botón, parámetros) {
    toggle(button, params["show".concat(capitalizeFirstLetter(buttonType), "Button")], 'inline-block');
    setInnerHtml(button, params["".concat(buttonType, "ButtonText")]); // Establecer el texto del título

    button.setAttribute('aria-label', params["".concat(buttonType, "ButtonAriaLabel")]); // etiqueta ARIA
    // Agregar clases personalizadas de botones

    button.className = swalClasses[buttonType];
    applyCustomClass(button, params, "".concat(buttonType, "Button"));
    addClass(button, params["".concat(buttonType, "ButtonClass")]);
  }

  función handleBackdropParam(contenedor, telón de fondo) {
    if (tipo de telón de fondo === 'cadena') {
      container.style.background = telón de fondo;
    } más si (! telón de fondo) {
      addClass([document.documentElement, document.body], swalClasses['no-backdrop']);
    }
  }

  función handlePositionParam(contenedor, posición) {
    if (posición en swalClasses) {
      addClass(contenedor, swalClasses[posición]);
    } demás {
      warn('El parámetro "posición" no es válido, por defecto es "centro"');
      addClass(contenedor, swalClasses.center);
    }
  }

  función handleGrowParam(contenedor, crecer) {
    if (crecer && tipo de crecer === 'cadena') {
      const crecerClase = "crecer-".concat(crecer);

      if (crecerClase en swalClasses) {
        addClass(contenedor, swalClasses[growClass]);
      }
    }
  }

  const renderContainer = (instancia, parámetros) => {
    const contenedor = getContainer();

    si (! contenedor) {
      regreso;
    }

    handleBackdropParam(contenedor, params.backdrop);
    handlePositionParam(contenedor, params.position);
    handleGrowParam(contenedor, params.grow); // clase personalizada

    applyCustomClass(contenedor, parámetros, 'contenedor');
  };

  /**
   * Este módulo contiene `WeakMap`s para cada "propiedad privada" efectiva que tiene un `Swal`.
   * Por ejemplo, para establecer la propiedad privada "foo" de `this` en "bar", puede `privateProps.foo.set(this, 'bar')`
   * Este es el enfoque que Babel probablemente adoptará para implementar métodos/campos privados
   * https://github.com/tc39/proposal-private-methods
   * https://github.com/babel/babel/pull/7555
   * Una vez que tengamos los cambios de ese PR en Babel, y nuestra clase principal encaje razonablemente en *un módulo*
   * entonces podemos usar esa función de idioma.
   */
  var accesorios privados = {
    awaitingPromise: nuevo WeakMap(),
    promesa: nuevo WeakMap(),
    parámetros internos: nuevo mapa débil(),
    domCache: nuevo mapa débil()
  };

  const inputTypes = ['input', 'file', 'range', 'select', 'radio', 'checkbox', 'textarea'];
  const renderInput = (instancia, parámetros) => {
    const ventana emergente = getPopup();
    const innerParams = privateProps.innerParams.get(instancia);
    const renderizar = !innerParams || params.input !== innerParams.input;
    tipos de entrada. para cada uno (tipo de entrada => {
      const inputClass = swalClasses[inputType];
      const inputContainer = getDirectChildByClass(popup, inputClass); // establecer atributos

      setAttributes(inputType, params.inputAttributes); // establece la clase

      inputContainer.className = inputClass;

      si (renderizar) {
        ocultar (contenedor de entrada);
      }
    });

    if (parámetros.entrada) {
      si (renderizar) {
        showInput(parámetros);
      } // establece una clase personalizada


      setCustomClass(parámetros);
    }
  };

  const showInput = parámetros => {
    if (!renderInputType[params.input]) {
      return error("¡Tipo de entrada inesperado! Se esperaba \"texto\", \"correo electrónico\", \"contraseña\", \"número\", \"tel\", \"seleccionar\", \"radio\ ", \"casilla de verificación\", \"área de texto\", \"archivo\" o \"url\", obtuvo \"".concat(params.input, "\""));
    }

    const inputContainer = getInputContainer(params.input);
    const input = renderInputType[params.input](inputContainer, params);
    mostrar (entrada); // entrada de enfoque automático

    establecerTiempo de espera(() => {
      entrada de enfoque (entrada);
    });
  };

  const removeAttributes = entrada => {
    for (sea i = 0; i < entrada.atributos.longitud; i++) {
      const atributoNombre = entrada.atributos[i].nombre;

      if (!['tipo', 'valor', 'estilo'].includes(atributo)) {
        input.removeAttribute(atributo);
      }
    }
  };

  const setAttributes = (tipo de entrada, atributos de entrada) => {
    const entrada = getInput(getPopup(), inputType);

    si (! entrada) {
      regreso;
    }

    removeAttributes(entrada);

    para (atributo constante en atributos de entrada) {
      input.setAttribute(attr, inputAttributes[attr]);
    }
  };

  const setClasePersonalizada = params => {
    const inputContainer = getInputContainer(params.input);

    if (params.customClass) {
      addClass(inputContainer, params.customClass.input);
    }
  };

  const setInputPlaceholder = (entrada, parámetros) => {
    if (!input.placeholder || params.inputPlaceholder) {
      input.placeholder = params.inputPlaceholder;
    }
  };

  const setInputLabel = (entrada, prependTo, parámetros) => {
    si (params.inputLabel) {
      entrada.id = swalClasses.input;
      const etiqueta = documento.createElement('etiqueta');
      const labelClass = swalClasses['input-label'];
      etiqueta.setAttribute('para', entrada.id);
      label.className = labelClass;
      addClass(etiqueta, params.customClass.inputLabel);
      label.innerText = params.inputLabel;
      prependTo.insertAdjacentElement('beforebegin', label);
    }
  };

  const getInputContainer = tipoEntrada => {
    const inputClass = swalClasses[inputType] ? swalClasses[inputType] : swalClasses.input;
    devuelve getDirectChildByClass(getPopup(), inputClass);
  };

  const renderInputType = {};

  renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = (entrada, parámetros) => {
    if (typeof params.inputValue === 'cadena' || typeof params.inputValue === 'número') {
      input.value = params.inputValue;
    } else if (!isPromise(params.inputValue)) {
      warn("¡Tipo inesperado de inputValue! Se esperaba \"string\", \"number\" o \"Promise\", obtuvo \"".concat(typeof params.inputValue, "\""));
    }

    setInputLabel(entrada, entrada, parámetros);
    setInputPlaceholder(entrada, parámetros);
    input.type = params.input;
    entrada de retorno;
  };

  renderInputType.file = (entrada, parámetros) => {
    setInputLabel(entrada, entrada, parámetros);
    setInputPlaceholder(entrada, parámetros);
    entrada de retorno;
  };

  renderInputType.range = (rango, parámetros) => {
    const rangeInput = range.querySelector('input');
    const rangoSalida = rango.querySelector('salida');
    rangeInput.value = params.inputValue;
    rangeInput.type = params.input;
    rangeOutput.value = params.inputValue;
    setInputLabel(rango de entrada, rango, parámetros);
    rango de retorno;
  };

  renderInputType.select = (seleccionar, parámetros) => {
    select.textContent = '';

    if (params.inputPlaceholder) {
      const marcador de posición = document.createElement('opción');
      setInnerHtml(marcador de posición, params.inputPlaceholder);
      marcador de posición.valor = '';
      marcador de posición.deshabilitado = verdadero;
      marcador de posición.seleccionado = verdadero;
      select.appendChild (marcador de posición);
    }

    setInputLabel(seleccionar, seleccionar, parámetros);
    volver seleccionar;
  };

  renderInputType.radio = radio => {
    radio.textContent = '';
    radio de retorno;
  };

  renderInputType.checkbox = (checkboxContainer, parámetros) => {
    /** @tipo {HTMLInputElement} */
    const checkbox = getInput(getPopup(), 'checkbox');
    casilla de verificación.valor = '1';
    checkbox.id = swalClasses.checkbox;
    checkbox.checked = Boolean(params.inputValue);
    const etiqueta = checkboxContainer.querySelector('span');
    setInnerHtml(etiqueta, params.inputPlaceholder);
    volver checkboxContainer;
  };

  renderInputType.textarea = (textarea, parámetros) => {
    textarea.value = params.inputValue;
    setInputPlaceholder(área de texto, parámetros);
    setInputLabel(área de texto, área de texto, parámetros);

    const getMargin = el => parseInt(window.getComputedStyle(el).marginLeft) + parseInt(window.getComputedStyle(el).marginRight); // https://github.com/sweetalert2/sweetalert2/issues/2291


    establecerTiempo de espera(() => {
      // https://github.com/sweetalert2/sweetalert2/issues/1699
      if ('MutationObserver' en la ventana) {
        const initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);

        const textareaResizeHandler = () => {
          const textareaWidth = textarea.offsetWidth + getMargin(textarea);

          if (textareaWidth > initialPopupWidth) {
            getPopup().style.width = "".concat(textareaWidth, "px");
          } demás {
            getPopup().estilo.ancho = nulo;
          }
        };

        nuevo MutationObserver(textareaResizeHandler).observe(textarea, {
          atributos: verdadero,
          atributoFilter: ['estilo']
        });
      }
    });
    devolver área de texto;
  };

  const renderContent = (instancia, parámetros) => {
    const htmlContainer = getHtmlContainer();
    applyCustomClass(htmlContainer, params, 'htmlContainer'); // Contenido como HTML

    si (parámetros.html) {
      parseHtmlToContainer(params.html, htmlContainer);
      show(htmlContainer, 'bloque');
    } // Contenido como texto sin formato
    más si (params.text) {
      htmlContainer.textContent = params.text;
      show(htmlContainer, 'bloque');
    } // Sin contenido
    demás {
      hide(htmlContenedor);
    }

    renderInput(instancia, parámetros);
  };

  const renderFooter = (instancia, parámetros) => {
    const pie de página = getFooter();
    alternar (pie de página, params.footer);

    if (parámetros.pie de página) {
      parseHtmlToContainer(parámetros.pie de página, pie de página);
    } // Clase personalizada


    applyCustomClass(pie de página, parámetros, 'pie de página');
  };

  const renderCloseButton = (instancia, parámetros) => {
    const botoncerrar = getBotonCerrar();
    setInnerHtml(closeButton, params.closeButtonHtml); // clase personalizada

    applyCustomClass(closeButton, params, 'closeButton');
    alternar (botóncerrar, params.mostrarBotónCerrar);
    closeButton.setAttribute('aria-label', params.closeButtonAriaLabel);
  };

  const renderIcon = (instancia, parámetros) => {
    const innerParams = privateProps.innerParams.get(instancia);
    const icono = getIcon(); // si el ícono dado ya está renderizado, aplica el estilo sin volver a renderizar el ícono

    if (innerParams && params.icon === innerParams.icon) {
      // Contenido personalizado o predeterminado
      setContent(icono, parámetros);
      applyStyles(icono, parámetros);
      regreso;
    }

    if (!params.icon && !params.iconHtml) {
      volver ocultar(icono);
    }

    if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {
      error("¡Icono desconocido! Se esperaba \"éxito\", \"error\", \"advertencia\", \"información\" o \"pregunta\", obtuve \"".concat(params.icon, "\ ""));
      volver ocultar(icono);
    }

    muestra el icono); // Contenido personalizado o predeterminado

    setContent(icono, parámetros);
    applyStyles(icono, parámetros); // Animar icono

    addClass(icono, params.showClass.icon);
  };

  const applyStyles = (icono, parámetros) => {
    para (const iconType en iconTypes) {
      if (parámetros.icono !== tipo de icono) {
        removeClass(icono, iconTypes[iconType]);
      }
    }

    addClass(icon, iconTypes[params.icon]); // color del icono

    setColor(icono, parametros); // Color de fondo del icono de éxito

    ajustar el color de fondo del icono del éxito (); // clase personalizada

    applyCustomClass(icono, parámetros, 'icono');
  }; // Ajuste el color de fondo del icono de éxito para que coincida con el color de fondo emergente


  const ajustarSuccessIconBackgroundColor = () => {
    const ventana emergente = getPopup();
    const popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue('background-color');
    const SuccessIconParts = popup.querySelectorAll('[clase^=swal2-success-circular-line], .swal2-success-fix');

    for (sea i = 0; i < exitIconParts.length; i++) {
      SuccessIconParts[i].style.backgroundColor = popupBackgroundColor;
    }
  };

  const SuccessIconHtml = "\n <div class=\"swal2-success-circular-line-left\"></div>\n <span class=\"swal2-success-line-tip\"></span> <span class=\"swal2-success-line-long\"></span>\n <div class=\"swal2-success-ring\"></div> <div class=\"swal2-success- fix\"></div>\n <div class=\"swal2-success-circular-line-right\"></div>\n";
  const errorIconHtml = "\n <span class=\"swal2-x-mark\">\n <span class=\"swal2-x-mark-line-left\"></span>\n <span class= \"swal2-x-mark-line-right\"></span>\n </span>\n";

  const setContent = (icono, parámetros) => {
    icono.textContent = '';

    si (parámetros.iconHtml) {
      setInnerHtml(icono, iconContent(params.iconHtml));
    } else if (params.icon === 'éxito') {
      setInnerHtml(icono, exitIconHtml);
    } else if (params.icon === 'error') {
      setInnerHtml(icono, errorIconHtml);
    } demás {
      const defaultIconHtml = {
        pregunta: '?',
        advertencia: '!',
        información: 'yo'
      };
      setInnerHtml(icon, iconContent(defaultIconHtml[params.icon]));
    }
  };

  const setColor = (icono, parámetros) => {
    if (!params.iconColor) {
      regreso;
    }

    icon.style.color = params.iconColor;
    icon.style.borderColor = params.iconColor;

    for (const sel of ['.swal2-success-line-tip', '.swal2-success-line-long', '.swal2-x-mark-line-left', '.swal2-x-mark-line -Correcto']) {
      setStyle(icon, sel, 'backgroundColor', params.iconColor);
    }

    setStyle(icon, '.swal2-success-ring', 'borderColor', params.iconColor);
  };

  const iconContent = contenido => "<div class=\"".concat(swalClasses['icon-content'], "\">").concat(content, "</div>");

  const renderImage = (instancia, parámetros) => {
    const imagen = getImagen();

    if (!params.imageUrl) {
      volver ocultar (imagen);
    }

    mostrar imagen, ''); // Origen, alt

    imagen.setAttribute('src', params.imageUrl);
    imagen.setAttribute('alt', params.imageAlt); // ancho, alto

    applyNumericalStyle(imagen, 'ancho', params.imageWidth);
    applyNumericalStyle(imagen, 'altura', params.imageHeight); // Clase

    imagen.className = swalClasses.image;
    applyCustomClass(imagen, parámetros, 'imagen');
  };

  const createStepElement = paso => ​​{
    const stepEl = document.createElement('li');
    addClass(stepEl, swalClasses['paso-progreso']);
    setInnerHtml(pasoEl, paso);
    volver stepEl;
  };

  const createLineElement = parámetros => {
    const lineEl = document.createElement('li');
    addClass(lineEl, swalClasses['progreso-paso-linea']);

    if (parámetros.progressStepsDistance) {
      lineEl.style.width = params.progressStepsDistance;
    }

    línea de retornoEl;
  };

  const renderProgressSteps = (instancia, parámetros) => {
    const ProgressStepsContainer = getProgressSteps();

    if (!params.progressSteps || params.progressSteps.length === 0) {
      return hide(progressStepsContainer);
    }

    mostrar (contenedor de pasos de progreso);
    progresoStepsContainer.textContent = '';

    if (params.currentProgressStep >= params.progressSteps.length) {
      warn('Parámetro currentProgressStep no válido, debe ser menor que progressSteps.length ' + '(currentProgressStep como matrices JS comienza desde 0)');
    }

    params.progressSteps.forEach((paso, índice) => {
      const stepEl = createStepElement(paso);
      progresoPasosContenedor.appendChild(pasoEl);

      if (índice === params.currentProgressStep) {
        addClass(stepEl, swalClasses['paso-de-progreso-activo']);
      }

      if (índice !== params.progressSteps.length - 1) {
        const lineEl = createLineElement(parámetros);
        ProgressStepsContainer.appendChild(lineEl);
      }
    });
  };

  const renderTitle = (instancia, parámetros) => {
    const titulo = obtenerTitulo();
    alternar (título, params.title || params.titleText, 'bloque');

    if (parámetros.título) {
      parseHtmlToContainer(parámetros.título, título);
    }

    if (params.titleText) {
      title.innerText = params.titleText;
    } // Clase personalizada


    applyCustomClass(título, parámetros, 'título');
  };

  const renderPopup = (instancia, parámetros) => {
    const contenedor = getContainer();
    const ventana emergente = getPopup(); // Ancho
    // https://github.com/sweetalert2/sweetalert2/issues/2170

    if (parámetros.brindis) {
      applyNumericalStyle(contenedor, 'ancho', params.ancho);
      popup.estilo.ancho = '100%';
      popup.insertBefore(getLoader(), getIcon());
    } demás {
      applyNumericalStyle(popup, 'ancho', params.width);
    } // Relleno


    applyNumericalStyle(popup, 'padding', params.padding); // Color

    if (parámetros.color) {
      popup.style.color = params.color;
    } // Antecedentes


    si (parámetros.fondo) {
      popup.style.background = params.background;
    }

    hide(getValidationMessage()); // Clases

    addClasses(ventana emergente, parámetros);
  };

  const addClasses = (ventana emergente, parámetros) => {
    // Clase predeterminada + showClass al actualizar Swal.update({})
    popup.className = "".concat(swalClasses.popup, " ").concat(isVisible(popup) ? params.showClass.popup : '');

    if (parámetros.brindis) {
      addClass([document.documentElement, document.body], swalClasses['toast-shown']);
      addClass(popup, swalClasses.toast);
    } demás {
      addClass(popup, swalClasses.modal);
    } // Clase personalizada


    applyCustomClass(ventana emergente, parámetros, 'ventana emergente');

    if (typeof params.customClass === 'cadena') {
      addClass(popup, params.customClass);
    } // Clase de icono (#1842)


    si (params.icon) {
      addClass(popup, swalClasses["icon-".concat(params.icon)]);
    }
  };

  const render = (instancia, parámetros) => {
    renderPopup(instancia, parámetros);
    renderContainer(instancia, parámetros);
    renderProgressSteps(instancia, parámetros);
    renderIcon(instancia, parámetros);
    renderImage(instancia, parámetros);
    renderTitle(instancia, parámetros);
    renderCloseButton(instancia, parámetros);
    renderContent(instancia, parámetros);
    renderActions(instancia, parámetros);
    renderFooter(instancia, parámetros);

    if (tipo de params.didRender === 'función') {
      params.didRender(getPopup());
    }
  };

  const DismissReason = Object.freeze({
    cancelar: 'cancelar',
    telón de fondo: 'telón de fondo',
    cerca cerca',
    esc: 'esc',
    temporizador: 'temporizador'
  });

  // Agregar aria-hidden="true" a elementos fuera del diálogo modal activo asegura que
  // los elementos que no estén dentro del cuadro de diálogo modal activo no aparecerán si un usuario abre una pantalla
  // lista de elementos del lector (encabezados, controles de formulario, puntos de referencia, etc.) en el documento.

  const setAriaHidden = () => {
    const bodyChildren = toArray(document.body.children);
    cuerpoNiños.paraCada(el => {
      if (el === getContainer() || el.contains(getContainer())) {
        regreso;
      }

      if (el.hasAttribute('aria-hidden')) {
        el.setAttribute('datos-anteriores-aria-ocultos', el.getAttribute('aria-ocultos'));
      }

      el.setAttribute('aria-hidden', 'true');
    });
  };
  const unsetAriaHidden = () => {
    const bodyChildren = toArray(document.body.children);
    cuerpoNiños.paraCada(el => {
      if (el.hasAttribute('datos-anteriores-aria-ocultos')) {
        el.setAttribute('aria-hidden', el.getAttribute('data-previous-aria-hidden'));
        el.removeAttribute('datos-anteriores-aria-ocultos');
      } demás {
        el.removeAttribute('aria-hidden');
      }
    });
  };

  const swalStringParams = ['swal-title', 'swal-html', 'swal-footer'];
  const getTemplateParams = params => {
    const template = typeof params.template === 'cadena' ? document.querySelector(params.template) : params.template;

    si (! plantilla) {
      regreso {};
    }
    /** @tipo {Fragmento del documento} */


    const templateContent = template.content;
    showWarningsForElements(templateContent);
    const resultado = Object.assign(getSwalParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));
    resultado devuelto;
  };
  /**
   * @param {DocumentFragment} templateContent
   */

  const getSwalParams = templateContent => {
    resultado constante = {};
    toArray(templateContent.querySelectorAll('swal-param')).forEach(param => {
      showWarningsForAttributes(parámetro, ['nombre', 'valor']);
      const paramName = param.getAttribute('nombre');
      valor const = param.getAttribute('valor');

      if (typeof defaultParams[paramName] === 'booleano' && valor === 'falso') {
        resultado[paramName] = falso;
      }

      if (typeof defaultParams[paramName] === 'objeto') {
        resultado[paramName] = JSON.parse(valor);
      }
    });
    resultado devuelto;
  };
  /**
   * @param {DocumentFragment} templateContent
   */


  const getSwalButtons = templateContent => {
    resultado constante = {};
    toArray(templateContent.querySelectorAll('swal-button')).forEach(button => {
      showWarningsForAttributes(botón, ['tipo', 'color', 'etiqueta-aria']);
      const tipo = botón.getAttribute('tipo');
      result["".concat(type, "ButtonText")] = button.innerHTML;
      result["mostrar".concat(mayúsculasPrimeraLetra(tipo), "Botón")] = true;

      if (boton.hasAttribute('color')) {
        result["".concat(type, "ButtonColor")] = button.getAttribute('color');
      }

      if (boton.hasAttribute('aria-label')) {
        result["".concat(type, "ButtonAriaLabel")] = button.getAttribute('aria-label');
      }
    });
    resultado devuelto;
  };
  /**
   * @param {DocumentFragment} templateContent
   */


  const getSwalImage = templateContent => {
    resultado constante = {};
    /** @tipo {HTMLElement} */

    const image = templateContent.querySelector('swal-image');

    si (imagen) {
      showWarningsForAttributes(imagen, ['origen', 'ancho', 'alto', 'alt']);

      if (imagen.hasAttribute('src')) {
        resultado.imageUrl = imagen.getAttribute('src');
      }

      if (imagen.hasAttribute('ancho')) {
        resultado.imageWidth = image.getAttribute('ancho');
      }

      if (imagen.hasAttribute('altura')) {
        resultado.imageHeight = image.getAttribute('altura');
      }

      if (imagen.hasAttribute('alt')) {
        resultado.imagenAlt = imagen.getAttribute('alt');
      }
    }

    resultado devuelto;
  };
  /**
   * @param {DocumentFragment} templateContent
   */


  const getSwalIcon = templateContent => {
    resultado constante = {};
    /** @tipo {HTMLElement} */

    const icon = templateContent.querySelector('swal-icon');

    si (icono) {
      showWarningsForAttributes(icono, ['tipo', 'color']);

      if (icono.hasAttribute('tipo')) {
        resultado.icono = icono.getAttribute('tipo');
      }

      if (icono.hasAttribute('color')) {
        resultado.iconColor = icon.getAttribute('color');
      }

      resultado.iconHtml = icon.innerHTML;
    }

    resultado devuelto;
  };
  /**
   * @param {DocumentFragment} templateContent
   */


  const getSwalInput = templateContent => {
    resultado constante = {};
    /** @tipo {HTMLElement} */

    const input = templateContent.querySelector('swal-input');

    si (entrada) {
      showWarningsForAttributes(input, ['tipo', 'etiqueta', 'marcador de posición', 'valor']);
      resultado.entrada = entrada.getAttribute('tipo') || 'texto';

      if (entrada.hasAttribute('etiqueta')) {
        resultado.inputLabel = input.getAttribute('etiqueta');
      }

      if (input.hasAttribute('marcador de posición')) {
        result.inputPlaceholder = input.getAttribute('placeholder');
      }

      if (entrada.hasAttribute('valor')) {
        resultado.inputValue = input.getAttribute('valor');
      }
    }

    const inputOptions = templateContent.querySelectorAll('swal-input-option');

    if (opcionesdeentrada.longitud) {
      resultado.opciones de entrada = {};
      toArray(inputOptions).forEach(opción => {
        showWarningsForAttributes(opción, ['valor']);
        const optionValue = option.getAttribute('value');
        const optionName = option.innerHTML;
        result.inputOptions[optionValue] = optionName;
      });
    }

    resultado devuelto;
  };
  /**
   * @param {DocumentFragment} templateContent
   * @param {cadena[]} paramNames
   */


  const getSwalStringParams = (templateContent, paramNames) => {
    resultado constante = {};

    for (const i en paramNames) {
      const paramName = paramNames[i];
      /** @tipo {HTMLElement} */

      const etiqueta = templateContent.querySelector(paramName);

      si (etiqueta) {
        showWarningsForAttributes(etiqueta, []);
        result[paramName.replace(/^swal-/, '')] = tag.innerHTML.trim();
      }
    }

    resultado devuelto;
  };
  /**
   * @param {DocumentFragment} templateContent
   */


  const mostrarAdvertenciasParaElementos = templateContent => {
    const allowElements = swalStringParams.concat(['swal-param', 'swal-button', 'swal-image', 'swal-icon', 'swal-input', 'swal-input-option']);
    toArray(templateContent.children).forEach(el => {
      const tagName = el.tagName.toLowerCase();

      if (elementospermitidos.indexOf(tagName) === -1) {
        warn("Elemento no reconocido <".concat(tagName, ">"));
      }
    });
  };
  /**
   * @param {HTMLElement} el
   * @param {cadena []} atributos permitidos
   */


  const mostrarAdvertenciasParaAtributos = (el, atributos permitidos) => {
    toArray(el.atributos).forEach(atributo => {
      if (atributospermitidos.indexOf(atributo.nombre) === -1) {
        warn(["Atributo no reconocido \"".concat(attribute.name, "\" on <").concat(el.tagName.toLowerCase(), ">."), "".concat(allowedAttributes.length ? " Los atributos permitidos son: ".concat(allowedAttributes.join(', ')) : 'Para establecer el valor, use HTML dentro del elemento.')]);
      }
    });
  };

  var defaultInputValidators = {
    correo electrónico: (cadena, mensaje de validación) => {
      return /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]{2,24}$/. prueba (cadena)? Promise.resolve() : Promise.resolve(validationMessage || 'Dirección de correo electrónico no válida');
    },
    url: (cadena, mensaje de validación) => {
      // tomado de https://stackoverflow.com/a/3809435 con un pequeño cambio de #1306 y #2013
      volver /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[az]{2,63}\b ([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(cadena) ? Promise.resolve() : Promise.resolve(validationMessage || 'URL no válida');
    }
  };

  función setDefaultInputValidators(parámetros) {
    // Use `inputValidator` predeterminado para los tipos de entrada admitidos si no se proporciona
    si (!params.inputValidator) {
      Objeto.claves(Validadores de entrada predeterminados).forEach(clave => {
        if (params.input === clave) {
          params.inputValidator = defaultInputValidators[clave];
        }
      });
    }
  }

  function validarElementoObjetivoPersonalizado(parámetros) {
    // Determinar si el elemento de destino personalizado es válido
    if (!params.target || typeof params.target === 'string' && !document.querySelector(params.target) || typeof params.target !== 'string' && !params.target.appendChild) {
      warn('El parámetro de destino no es válido, por defecto es "cuerpo"');
      params.objetivo = 'cuerpo';
    }
  }
  /**
   * Establecer tipo, texto y acciones en la ventana emergente
   *
   * @param parámetros
   */


  función setParameters(parámetros) {
    setDefaultInputValidators(parámetros); // showLoaderOnConfirm && preconfirmar

    if (parámetros.showLoaderOnConfirm && !params.preConfirm) {
      warn('showLoaderOnConfirm se establece en verdadero, pero preConfirm no está definido.\n' + 'showLoaderOnConfirm debe usarse junto con preConfirm, consulte el ejemplo de uso:\n' + 'https://sweetalert2.github.io/#ajax- solicitud');
    }

    validarElementoObjetivoPersonalizado(parámetros); // Reemplazar líneas nuevas con <br> en el título

    if (typeof params.title === 'cadena') {
      params.title = params.title.split('\n').join('<br />');
    }

    init(parámetros);
  }

  temporizador de clase {
    constructor (devolución de llamada, retraso) {
      this.devolución de llamada = devolución de llamada;
      this.remaining = retraso;
      esto.en ejecución = falso;
      esto.inicio();
    }

    comienzo() {
      si (!esta.corriendo) {
        esto.en ejecución = verdadero;
        this.started = nueva Fecha();
        this.id = setTimeout(this.callback, this.remaining);
      }

      devolver este.restante;
    }

    detener() {
      si (esto.en ejecución) {
        esto.en ejecución = falso;
        clearTimeout(este.id);
        this.remaining -= new Date().getTime() - this.started.getTime();
      }

      devolver este.restante;
    }

    aumentar(n) {
      const corriendo = this.running;

      si (corriendo) {
        esto.detener();
      }

      este.restante += n;

      si (corriendo) {
        esto.inicio();
      }

      devolver este.restante;
    }

    getTimerLeft() {
      si (esto.en ejecución) {
        esto.detener();
        esto.inicio();
      }

      devolver este.restante;
    }

    Esta corriendo() {
      devuelve esto.ejecutando;
    }

  }

  const fixScrollbar = () => {
    // para las colas, no hagas esto más de una vez
    if (estados.anteriorBodyPadding !== nulo) {
      regreso;
    } // si el cuerpo tiene desbordamiento


    if (documento.cuerpo.scrollHeight > ventana.innerHeight) {
      // agregue relleno para que el contenido no cambie después de eliminar la barra de desplazamiento
      estados.previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue('relleno-derecho'));
      document.body.style.paddingRight = "".concat(states.previousBodyPadding + MeasureScrollbar(), "px");
    }
  };
  const deshacer barra de desplazamiento = () => {
    if (estados.anteriorBodyPadding !== nulo) {
      document.body.style.paddingRight = "".concat(states.previousBodyPadding, "px");
      estados.anteriorBodyPadding = nulo;
    }
  };

  /* estambul ignora el archivo */

  const iOSfix = () => {
    const iOS = // @ts-ignorar
    /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || navegador.plataforma === 'MacIntel' && navegador.maxTouchPoints > 1;

    if (iOS && !hasClass(document.body, swalClasses.iosfix)) {
      const desplazamiento = documento.cuerpo.scrollTop;
      document.body.style.top = "".concat(offset * -1, "px");
      addClass(documento.cuerpo, swalClasses.iosfix);
      bloquear desplazamiento del cuerpo ();
      addBottomPaddingForTallPopups();
    }
  };
  /**
   * https://github.com/sweetalert2/sweetalert2/issues/1948
   */

  const addBottomPaddingForTallPopups = () => {
    const ua = navigator.userAgent;
    constante iOS = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i);
    const webkit = !!ua.match(/WebKit/i);
    const iOSSafari = iOS && webkit && !ua.match(/CriOS/i);

    si (iOSSafari) {
      const bottomPanelHeight = 44;

      if (getPopup().scrollHeight > window.innerHeight - bottomPanelHeight) {
        getContainer().style.paddingBottom = "".concat(bottomPanelHeight, "px");
      }
    }
  };
  /**
   * https://github.com/sweetalert2/sweetalert2/issues/1246
   */


  const lockBodyScroll = () => {
    const contenedor = getContainer();
    dejar prevenirTouchMove;

    container.ontouchstart = e => {
      prevenirTocarMove = debePrevenirTocarMove(e);
    };

    container.ontouchmove = e => {
      si (prevenir TouchMove) {
        e.preventDefault();
        e.detener la propagación();
      }
    };
  };

  const debePrevenirTocarMoverse = evento => {
    objetivo const = evento.objetivo;
    const contenedor = getContainer();

    if (esStylus(evento) || isZoom(evento)) {
      falso retorno;
    }

    if (objetivo === contenedor) {
      devolver verdadero;
    }

    if (!isScrollable(container) && target.tagName !== 'ENTRADA' && // #1603
    target.tagName !== 'TEXTAREA' && // #2266
    !(esDesplazable(getHtmlContainer()) && // #1944
    getHtmlContainer().contains(objetivo))) {
      devolver verdadero;
    }

    falso retorno;
  };
  /**
   * https://github.com/sweetalert2/sweetalert2/issues/1786
   *
   * @param {*} evento
   * @devoluciones {booleano}
   */


  const esStylus = evento => {
    return event.touches && event.touches.length && event.touches[0].touchType === 'stylus';
  };
  /**
   * https://github.com/sweetalert2/sweetalert2/issues/1891
   *
   * evento @param {TouchEvent}
   * @devoluciones {booleano}
   */


  const esZoom = evento => {
    return evento.toques && evento.toques.longitud > 1;
  };

  const deshacer IOSfix = () => {
    if (hasClass(document.body, swalClasses.iosfix)) {
      const offset = parseInt(document.body.style.top, 10);
      removeClass(document.body, swalClasses.iosfix);
      documento.cuerpo.estilo.top = '';
      documento.cuerpo.scrollTop = desplazamiento * -1;
    }
  };

  const SHOW_CLASS_TIMEOUT = 10;
  /**
   * Abra una ventana emergente, agregue las clases y estilos necesarios, corrija la barra de desplazamiento
   *
   * @param parámetros
   */

  const openPopup = parámetros => {
    const contenedor = getContainer();
    const ventana emergente = getPopup();

    if (tipo de params.willOpen === 'función') {
      params.willOpen(ventana emergente);
    }

    const bodyStyles = window.getComputedStyle(document.body);
    const initialBodyOverflow = bodyStyles.overflowY;
    addClasses$1(contenedor, ventana emergente, parámetros); // el desplazamiento está 'oculto' hasta que finaliza la animación, después de eso 'automático'

    establecerTiempo de espera(() => {
      setScrollingVisibility(contenedor, ventana emergente);
    }, MOSTRAR_CLASE_TIEMPO ESPERA);

    si (esModal()) {
      fixScrollContainer(contenedor, params.scrollbarPadding, initialBodyOverflow);
      setAriaOculta();
    }

    if (!isToast() && !globalState.previousActiveElement) {
      globalState.previousActiveElement = documento.activeElement;
    }

    if (tipo de params.didOpen === 'función') {
      setTimeout(() => params.didOpen(popup));
    }

    removeClass(contenedor, swalClasses['sin transición']);
  };

  const swalOpenAnimationFinished = evento => {
    const ventana emergente = getPopup();

    if (evento.objetivo !== ventana emergente) {
      regreso;
    }

    const contenedor = getContainer();
    popup.removeEventListener(animationEndEvent, swalOpenAnimationFinished);
    container.style.overflowY = 'auto';
  };

  const setScrollingVisibility = (contenedor, ventana emergente) => {
    if (animationEndEvent && hasCssAnimation(popup)) {
      container.style.overflowY = 'oculto';
      popup.addEventListener(animationEndEvent, swalOpenAnimationFinished);
    } demás {
      container.style.overflowY = 'auto';
    }
  };

  const fixScrollContainer = (contenedor, scrollbarPadding, initialBodyOverflow) => {
    corrección de iOS();

    if (scrollbarPadding && initialBodyOverflow !== 'oculto') {
      fixScrollbar();
    } // dulcealerta2/problemas/1247


    establecerTiempo de espera(() => {
      contenedor.scrollTop = 0;
    });
  };

  const addClasses$1 = (contenedor, ventana emergente, parámetros) => {
    addClass(contenedor, params.showClass.backdrop); // esta solución con opacidad es necesaria para https://github.com/sweetalert2/sweetalert2/issues/2059

    popup.style.setProperty('opacidad', '0', 'importante');
    mostrar (ventana emergente, 'cuadrícula');
    establecerTiempo de espera(() => {
      // Animar ventana emergente justo después de mostrarla
      addClass(emergente, params.showClass.popup); // y eliminar la solución de opacidad

      popup.style.removeProperty('opacidad');
    }, MOSTRAR_CLASE_TIEMPO ESPERA); // 10ms para arreglar #2062

    addClass([document.documentElement, document.body], swalClasses.shown);

    if (params.heightAuto && params.backdrop && !params.toast) {
      addClass([document.documentElement, document.body], swalClasses['height-auto']);
    }
  };

  /**
   * Muestra el cargador (spinner), esto es útil con las solicitudes de AJAX.
   * Por defecto se mostrará el cargador en lugar del botón "Confirmar".
   */

  const showLoading = buttonToReplace => {
    dejar emergente = getPopup();

    si (! ventana emergente) {
      nuevo Swal(); // eslint-disable-line no-new
    }

    ventana emergente = getPopup();
    const cargador = getLoader();

    si (es una tostada()) {
      ocultar(obtenerIcono());
    } demás {
      replaceButton(emergente, buttonToReplace);
    }

    mostrar (cargador);
    popup.setAttribute('carga de datos', verdadero);
    popup.setAttribute('aria-ocupado', verdadero);
    popup.foco();
  };

  const replaceButton = (ventana emergente, buttonToReplace) => {
    const acciones = getActions();
    const cargador = getLoader();

    if (!buttonToReplace && isVisible(getConfirmButton())) {
      buttonToReplace = getConfirmButton();
    }

    mostrar(acciones);

    si (botón para reemplazar) {
      ocultar (botón para reemplazar);
      loader.setAttribute('botón-de-datos-para-reemplazar', buttonToReplace.className);
    }

    loader.parentNode.insertBefore(loader, buttonToReplace);
    addClass([ventana emergente, acciones], swalClasses.loading);
  };

  const handleInputOptionsAndValue = (instancia, parámetros) => {
    if (params.input === 'seleccionar' || params.input === 'radio') {
      handleInputOptions(instancia, parámetros);
    } else if (['text', 'email', 'number', 'tel', 'textarea'].includes(params.input) && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {
      showLoading(getConfirmButton());
      handleInputValue(instancia, parámetros);
    }
  };
  const getInputValue = (instancia, parámetros internos) => {
    const entrada = instancia.getInput();

    si (! entrada) {
      devolver nulo;
    }

    cambiar (innerParams.input) {
      caso 'casilla de verificación':
        devuelve getCheckboxValue(entrada);

      caso 'radio':
        devuelve getRadioValue(entrada);

      expediente':
        devuelve getFileValue(entrada);

      por defecto:
        devolver parámetros internos.inputAutoTrim? entrada.valor.trim() : entrada.valor;
    }
  };

  const getCheckboxValue = input => input.checked ? 1 : 0;

  const getRadioValue = input => input.checked ? valor de entrada: nulo;

  const getFileValue = entrada => entrada.archivos.longitud ? input.getAttribute('múltiple') !== nulo ? archivos de entrada: archivos de entrada [0]: nulo;

  const handleInputOptions = (instancia, parámetros) => {
    const ventana emergente = getPopup();

    const processInputOptions = inputOptions => populateInputOptions[params.input](popup, formatInputOptions(inputOptions), params);

    if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {
      showLoading(getConfirmButton());
      asPromise(params.inputOptions).then(inputOptions => {
        instancia.hideLoading();
        procesarOpcionesDeEntrada(opcionesdeentrada);
      });
    } else if (typeof params.inputOptions === 'objeto') {
      processInputOptions(parámetros.inputOptions);
    } demás {
      error("¡Tipo inesperado de opciones de entrada! Objeto esperado, Mapa o Promesa, obtuve ".concat(tipo de params.inputOptions));
    }
  };

  const handleInputValue = (instancia, parámetros) => {
    const entrada = instancia.getInput();
    ocultar (entrada);
    asPromise(params.inputValue).then(inputValue => {
      input.value = params.input === 'número' ? parseFloat(valorEntrada) || 0 : "".concat(valorEntrada);
      mostrar (entrada);
      entrada.focus();
      instancia.hideLoading();
    }).catch(error => {
      error("Error en la promesa inputValue: ".concat(err));
      entrada.valor = '';
      mostrar (entrada);
      entrada.focus();
      instancia.hideLoading();
    });
  };

  const populateInputOptions = {
    seleccione: (ventana emergente, opciones de entrada, parámetros) => {
      const select = getDirectChildByClass(popup, swalClasses.select);

      const renderOption = (principal, optionLabel, optionValue) => {
        opción const = document.createElement('opción');
        opción.valor = opciónValor;
        setInnerHtml(opción, opciónEtiqueta);
        opción.seleccionado = isSelected(optionValue, params.inputValue);
        padre.appendChild(opción);
      };

      inputOptions.forEach(inputOption => {
        const optionValue = inputOption[0];
        const optionLabel = inputOption[1]; // especificación <optgroup>:
        // https://www.w3.org/TR/html401/interact/forms.html#h-17.6
        // "...todos los elementos OPTGROUP deben especificarse directamente dentro de un elemento SELECT (es decir, los grupos no pueden estar anidados)..."
        // comprobar si se trata de un <optgroup>

        if (Array.isArray(optionLabel)) {
          // si es una matriz, entonces es un <optgroup>
          const optgroup = document.createElement('optgroup');
          optgroup.label = optionValue;
          optgroup.deshabilitado = falso; // no configurable por ahora

          select.appendChild (grupo de opciones);
          optionLabel.forEach(o => renderOption(optgroup, o[1], o[0]));
        } demás {
          // caso de <opción>
          renderOption(select, optionLabel, optionValue);
        }
      });
      seleccionar.focus();
    },
    radio: (ventana emergente, opciones de entrada, parámetros) => {
      const radio = getDirectChildByClass(popup, swalClasses.radio);
      inputOptions.forEach(inputOption => {
        const radioValor = inputOption[0];
        const radioLabel = inputOption[1];
        const radioInput = document.createElement('input');
        const radioLabelElement = document.createElement('etiqueta');
        entrada de radio.tipo = 'radio';
        radioInput.nombre = swalClasses.radio;
        radioEntrada.valor = radioValor;

        if (isSelected(radioValue, params.inputValue)) {
          radioInput.checked = verdadero;
        }

        const etiqueta = document.createElement('span');
        setInnerHtml(etiqueta, etiqueta de radio);
        label.className = swalClasses.label;
        radioLabelElement.appendChild(entrada de radio);
        radioLabelElement.appendChild(etiqueta);
        radio.appendChild(radioLabelElement);
      });
      const radios = radio.querySelectorAll('entrada');

      if (radios.longitud) {
        radios[0].focus();
      }
    }
  };
  /**
   * Convierte `inputOptions` en una matriz de `[valor, etiqueta]`s
   * @param opciones de entrada
   */

  const formatInputOptions = inputOptions => {
    resultado constante = [];

    if (typeof Map !== 'undefined' && inputOptions instanceof Map) {
      inputOptions.forEach((valor, clave) => {
        let valorFormatted = valor;

        if (tipo de valor Formateado === 'objeto') {
          // caso de <optgroup>
          valueFormatted = formatInputOptions(valueFormatted);
        }

        resultado.push([clave, formato de valor]);
      });
    } demás {
      Objeto.claves(opcionesdeentrada).forEach(clave => {
        let valueFormatted = inputOptions[clave];

        if (tipo de valor Formateado === 'objeto') {
          // caso de <optgroup>
          valueFormatted = formatInputOptions(valueFormatted);
        }

        resultado.push([clave, formato de valor]);
      });
    }

    resultado devuelto;
  };

  const isSelected = (optionValue, inputValue) => {
    return inputValue && inputValue.toString() === optionValue.toString();
  };

  /**
   * Oculta el cargador y muestra el botón que estaba oculto por .showLoading()
   */

  función ocultarCargar() {
    // no hacer nada si la ventana emergente está cerrada
    const innerParams = privateProps.innerParams.get(esto);

    if (!innerParams) {
      regreso;
    }

    const domCache = privateProps.domCache.get(esto);
    hide(domCache.loader);

    si (es una tostada()) {
      si (innerParams.icon) {
        mostrar(obtenerIcono());
      }
    } demás {
      mostrarBotónRelacionado(domCache);
    }

    removeClass([domCache.popup, domCache.actions], swalClasses.loading);
    domCache.popup.removeAttribute('aria-ocupado');
    domCache.popup.removeAttribute('carga de datos');
    domCache.confirmButton.disabled = falso;
    domCache.denyButton.disabled = falso;
    domCache.cancelButton.disabled = falso;
  }

  const showRelatedButton = domCache => {
    const buttonToReplace = domCache.popup.getElementsByClassName(domCache.loader.getAttribute('data-button-to-replace'));

    if (botónParaReemplazar.longitud) {
      show(buttonToReplace[0], 'bloque en línea');
    } más si (todos los botones están ocultos ()) {
      hide(domCache.acciones);
    }
  };

  /**
   * Obtiene el nodo DOM de entrada, este método funciona con el parámetro de entrada.
   * @devoluciones {HTMLElement | nulo}
   */

  función getInput$1(instancia) {
    const innerParams = privateProps.innerParams.get(instancia || esto);
    const domCache = privateProps.domCache.get(instancia || esto);

    si (!domCache) {
      devolver nulo;
    }

    volver getInput(domCache.popup, innerParams.input);
  }

  /**
   * Este módulo contiene `WeakMap`s para cada "propiedad privada" efectiva que tiene un `Swal`.
   * Por ejemplo, para establecer la propiedad privada "foo" de `this` en "bar", puede `privateProps.foo.set(this, 'bar')`
   * Este es el enfoque que Babel probablemente adoptará para implementar métodos/campos privados
   * https://github.com/tc39/proposal-private-methods
   * https://github.com/babel/babel/pull/7555
   * Una vez que tengamos los cambios de ese PR en Babel, y nuestra clase principal encaje razonablemente en *un módulo*
   * entonces podemos usar esa función de idioma.
   */
  var métodosprivados = {
    swalPromiseResolve: nuevo WeakMap(),
    swalPromiseReject: nuevo WeakMap()
  };

  /*
   * Método de instancia para cerrar sweetAlert
   */

  función removePopupAndResetState(instancia, contenedor, returnFocus, didClose) {
    si (es una tostada()) {
      triggerDidCloseAndDispose(instancia, didClose);
    } demás {
      restoreActiveElement(returnFocus).then(() => triggerDidCloseAndDispose(instancia, didClose));
      globalState.keydownTarget.removeEventListener('keydown', globalState.keydownHandler, {
        captura: globalState.keydownListenerCapture
      });
      globalState.keydownHandlerAdded = falso;
    }

    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent); // solución para #2088
    // por alguna razón, al eliminar el contenedor en Safari, el documento se desplazará hacia abajo

    si (es Safari) {
      container.setAttribute('estilo', 'display:none !important');
      container.removeAttribute('clase');
      contenedor.innerHTML = '';
    } demás {
      contenedor.remove();
    }

    si (esModal()) {
      deshacer la barra de desplazamiento ();
      deshacer IOSfix();
      unsetAriaHidden();
    }

    removeBodyClasses();
  }

  función removeBodyClasses() {
    removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses['height-auto'], swalClasses['no-backdrop'], swalClasses['toast-shown']]);
  }

  función cerrar (resolveValue) {
    resolverValor = prepararResolveValor(resolveValor);
    const swalPromiseResolve = privateMethods.swalPromiseResolve.get(esto);
    const didClose = triggerClosePopup(esto);

    if (this.isAwaitingPromise()) {
      // Un swal en espera de una promesa (después de hacer clic en Confirmar o Denegar) ya no se puede descartar #2335
      if (!resolveValue.isDismissed) {
        handleAwaitingPromise(esto);
        swalPromiseResolve(resolveValor);
      }
    } más si (hizoCerrar) {
      // Resolver la promesa Swal
      swalPromiseResolve(resolveValor);
    }
  }
  función estáEsperandoPromesa() {
    return !!privateProps.awaitingPromise.get(this);
  }

  const triggerClosePopup = instancia => {
    const ventana emergente = getPopup();

    si (! ventana emergente) {
      falso retorno;
    }

    const innerParams = privateProps.innerParams.get(instancia);

    if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {
      falso retorno;
    }

    removeClass(popup, innerParams.showClass.popup);
    addClass(popup, innerParams.hideClass.popup);
    const telón de fondo = getContainer();
    removeClass(backdrop, innerParams.showClass.backdrop);
    addClass(backdrop, innerParams.hideClass.backdrop);
    handlePopupAnimation(instancia, ventana emergente, parámetros internos);
    devolver verdadero;
  };

  function rechazarPromesa(error) {
    const rechazarPromise = privateMethods.swalPromiseReject.get(this);
    handleAwaitingPromise(esto);

    si (rechazar la promesa) {
      // Rechazar la promesa Swal
      rechazarPromesa(error);
    }
  }
  const handleAwaitingPromise = instancia => {
    if (instancia.estáEsperandoPromesa()) {
      privateProps.awaitingPromise.delete(instancia); // Es posible que la instancia haya sido parcialmente destruida previamente, debemos reanudar el proceso de destrucción en este caso #2335

      if (!privateProps.innerParams.get(instancia)) {
        instancia._destroy();
      }
    }
  };

  const prepararValorResolver = resolverValor => {
    // Cuando el usuario llama a Swal.close()
    if (tipo de resolveValue === 'indefinido') {
      regreso {
        está confirmado: falso,
        isDenied: falso,
        está descartado: verdadero
      };
    }

    devuelve Objeto.assignar({
      está confirmado: falso,
      isDenied: falso,
      está descartado: falso
    }, resolverValor);
  };

  const handlePopupAnimation = (instancia, ventana emergente, parámetros internos) => {
    const contenedor = getContainer(); // Si la animación es compatible, animar

    const animationIsSupported = animationEndEvent && hasCssAnimation(popup);

    if (typeof innerParams.willClose === 'función') {
      innerParams.willClose(ventana emergente);
    }

    si (la animación es compatible) {
      animatePopup(instancia, ventana emergente, contenedor, innerParams.returnFocus, innerParams.didClose);
    } demás {
      // De lo contrario, eliminar inmediatamente
      removePopupAndResetState(instancia, contenedor, innerParams.returnFocus, innerParams.didClose);
    }
  };

  const animatePopup = (instancia, ventana emergente, contenedor, returnFocus, didClose) => {
    globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instancia, contenedor, returnFocus, didClose);
    popup.addEventListener(animaciónEndEvent, función (e) {
      if (e.objetivo === ventana emergente) {
        globalState.swalCloseEventFinishedCallback();
        eliminar globalState.swalCloseEventFinishedCallback;
      }
    });
  };

  const triggerDidCloseAndDispose = (instancia, didClose) => {
    establecerTiempo de espera(() => {
      if (typeof didClose === 'función') {
        didClose.bind(instancia.parámetros)();
      }

      instancia._destroy();
    });
  };

  función setButtonsDisabled(instancia, botones, deshabilitado) {
    const domCache = privateProps.domCache.get(instancia);
    botones.paraCada(botón => {
      domCache[botón].deshabilitado = deshabilitado;
    });
  }

  función setInputDisabled(entrada, deshabilitada) {
    si (! entrada) {
      falso retorno;
    }

    if (entrada.tipo === 'radio') {
      const radiosContainer = input.parentNode.parentNode;
      const radios = radiosContainer.querySelectorAll('input');

      for (sea i = 0; i < radios.longitud; i++) {
        radios[i].disabled = deshabilitado;
      }
    } demás {
      entrada.deshabilitado = deshabilitado;
    }
  }

  función habilitarBotones() {
    setButtonsDisabled(this, ['confirmButton', 'denyButton', 'cancelButton'], false);
  }
  función deshabilitarBotones() {
    setButtonsDisabled(this, ['confirmButton', 'denyButton', 'cancelButton'], true);
  }
  función habilitarEntrada() {
    devuelve setInputDisabled(this.getInput(), false);
  }
  función deshabilitar entrada () {
    devuelve setInputDisabled(this.getInput(), true);
  }

  función mostrarMensajeValidación(error) {
    const domCache = privateProps.domCache.get(esto);
    const params = privateProps.innerParams.get(this);
    setInnerHtml(domCache.validationMessage, error);
    domCache.validationMessage.className = swalClasses['validation-message'];

    if (params.customClass && params.customClass.validationMessage) {
      addClass(domCache.validationMessage, params.customClass.validationMessage);
    }

    mostrar (domCache.validationMessage);
    const entrada = this.getInput();

    si (entrada) {
      input.setAttribute('aria-invalid', true);
      input.setAttribute('aria-descrito por', swalClasses['mensaje-de-validación']);
      entrada de enfoque (entrada);
      addClass(entrada, swalClasses.inputerror);
    }
  } // Ocultar bloque con mensaje de validación

  función resetValidationMessage$1() {
    const domCache = privateProps.domCache.get(esto);

    if (domCache.mensaje de validación) {
      ocultar (domCache.validationMessage);
    }

    const entrada = this.getInput();

    si (entrada) {
      input.removeAttribute('aria-invalid');
      input.removeAttribute('aria-descrita por');
      removeClass(entrada, swalClasses.inputerror);
    }
  }

  función obtenerPasosDeProgreso$1() {
    const domCache = privateProps.domCache.get(esto);
    volver domCache.progressSteps;
  }

  /**
   * Actualizaciones de parámetros emergentes.
   */

  actualización de funciones (parámetros) {
    const ventana emergente = getPopup();
    const innerParams = privateProps.innerParams.get(esto);

    if (!popup || hasClass(popup, innerParams.hideClass.popup)) {
      return warn("Está intentando actualizar la ventana emergente cerrada o que se está cerrando, eso no funcionará. Use el método update() en el parámetro preConfirm o muestre una nueva ventana emergente.");
    }

    const validUpdatableParams = filterValidParams(parámetros);
    const updateParams = Object.assign({}, innerParams, validUpdatableParams);
    render(esto, parámetros actualizados);
    privateProps.innerParams.set(this, updatedParams);
    Objeto.defineProperties(esto, {
      parámetros: {
        valor: Object.assign({}, this.params, params),
        escribible: falso,
        enumerable: verdadero
      }
    });
  }

  const filterValidParams = params => {
    const validUpdatableParams = {};
    Objeto.keys(parámetros).forEach(parámetro => {
      if (isUpdatableParameter(parámetro)) {
        validUpdatableParams[parámetro] = params[parámetro];
      } demás {
        warn("Parámetro no válido para actualizar: \"".concat(parámetro, "\". Los parámetros actualizables se enumeran aquí: https://github.com/sweetalert2/sweetalert2/blob/master/src/utils/params.js\ n\nSi cree que este parámetro debería ser actualizable, solicítelo aquí: https://github.com/sweetalert2/sweetalert2/issues/new?template=02_feature_request.md"));
      }
    });
    volver validUpdatableParams;
  };

  función _destroy() {
    const domCache = privateProps.domCache.get(esto);
    const innerParams = privateProps.innerParams.get(esto);

    if (!innerParams) {
      disposeWeakMaps(esto); // Los WeakMaps pueden haber sido parcialmente destruidos, debemos recuperarlos para deshacernos de cualquier WeakMaps restante #2335

      regreso; // Esta instancia ya ha sido destruida
    } // Comprobar si hay otro cierre de Swal


    if (domCache.popup && globalState.swalCloseEventFinishedCallback) {
      globalState.swalCloseEventFinishedCallback();
      eliminar globalState.swalCloseEventFinishedCallback;
    } // Comprobar si hay un temporizador de aplazamiento de eliminación de swal


    si (globalState.deferDisposalTimer) {
      clearTimeout(globalState.deferDisposalTimer);
      eliminar globalState.deferDisposalTimer;
    }

    if (tipo de parámetros internos.didDestroy === 'función') {
      ParámetrosInteriores.didDestroy();
    }

    disponerSwal(esto);
  }

  const disposeSwal = instancia => {
    disposeWeakMaps(instancia); // Desactive this.params para que GC lo deseche (#1569)

    eliminar instancia.params; // Desactiva los accesorios de globalState para que GC elimine globalState (#1569)

    eliminar globalState.keydownHandler;
    eliminar globalState.keydownTarget; // Desactivar instancia actual

    eliminar globalState.currentInstance;
  };

  const disposeWeakMaps = instancia => {
    // Si la instancia actual está esperando un resultado prometido, mantenemos los métodos privados para llamarlos una vez que se recupera el resultado prometido #2335
    if (instancia.estáEsperandoPromesa()) {
      unsetWeakMaps(privateProps, instancia);
      privateProps.awaitingPromise.set(instancia, verdadero);
    } demás {
      unsetWeakMaps(privateMethods, instancia);
      unsetWeakMaps(privateProps, instancia);
    }
  };

  const unsetWeakMaps = (obj, instancia) => {
    for (const i en obj) {
      obj[i].delete(instancia);
    }
  };



  var instanceMethods = /*#__PURE__*/Object.freeze({
    ocultarCargando: ocultarCargando,
    desactivar la carga: ocultar la carga,
    obtenerEntrada: obtenerEntrada$1,
    cerca cerca,
    está esperando una promesa: está esperando una promesa,
    rechazarPromesa: rechazarPromesa,
    handleAwaitingPromise: handleAwaitingPromise,
    closePopup: cerrar,
    cerrarModal: cerrar,
    closeToast: cerrar,
    botones habilitados: botones habilitados,
    desactivar botones: desactivar botones,
    habilitar entrada: habilitar entrada,
    deshabilitar entrada: deshabilitar entrada,
    mostrar mensaje de validación: mostrar mensaje de validación,
    resetValidationMessage: resetValidationMessage$1,
    obtenerPasosDeProgreso: obtenerPasosDeProgreso$1,
    actualizar: actualizar,
    _destruir: _destruir
  });

  const handleConfirmButtonClick = instancia => {
    const innerParams = privateProps.innerParams.get(instancia);
    instancia.disableButtons();

    if (innerParams.input) {
      handleConfirmOrDenyWithInput(instancia, 'confirmar');
    } demás {
      confirmar (instancia, verdadero);
    }
  };
  const handleDenyButtonClick = instancia => {
    const innerParams = privateProps.innerParams.get(instancia);
    instancia.disableButtons();

    si (innerParams.returnInputValueOnDeny) {
      handleConfirmOrDenyWithInput(instancia, 'denegar');
    } demás {
      negar (instancia, falso);
    }
  };
  const handleCancelButtonClick = (instancia, descartarCon) => {
    instancia.disableButtons();
    descartar con (DismissReason.cancel);
  };

  const handleConfirmOrDenyWithInput = (instancia, tipo
  /* 'confirmar' | 'negar' */
  ) => {
    const innerParams = privateProps.innerParams.get(instancia);

    if (!innerParams.input) {
      return error("Se necesita establecer el parámetro \"input\" cuando se usa returnInputValueOn".concat(capitalizeFirstLetter(type)));
    }

    const inputValue = getInputValue(instancia, parámetros internos);

    si (innerParams.inputValidator) {
      handleInputValidator(instancia, inputValue, tipo);
    } más si (! instancia.getInput().checkValidity()) {
      instancia.enableButtons();
      instancia.showValidationMessage(innerParams.validationMessage);
    } else if (escriba === 'denegar') {
      denegar (instancia, valor de entrada);
    } demás {
      confirmar (instancia, valor de entrada);
    }
  };

  const handleInputValidator = (instancia, inputValue, tipo
  /* 'confirmar' | 'negar' */
  ) => {
    const innerParams = privateProps.innerParams.get(instancia);
    instancia.disableInput();
    const validaciónPromise = Promise.resolve().then(() => asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage)));
    validaciónPromesa.entonces(validaciónMensaje => {
      instancia.enableButtons();
      instancia.enableInput();

      if (mensaje de validación) {
        instancia.showValidationMessage(validationMessage);
      } else if (escriba === 'denegar') {
        denegar (instancia, valor de entrada);
      } demás {
        confirmar (instancia, valor de entrada);
      }
    });
  };

  const deny = (instancia, valor) => {
    const innerParams = privateProps.innerParams.get(instancia || indefinido);

    si (innerParams.showLoaderOnDeny) {
      showLoading(getDenyButton());
    }

    si (innerParams.preDeny) {
      privateProps.awaitingPromise.set(instancia || indefinido, verdadero); // Marcar la instancia como en espera de una promesa para que los métodos de rechazo/resolver de su propia promesa no se destruyan hasta que se reciba el resultado de esta promesa de preDeny

      const preDenyPromise = Promise.resolve().then(() => asPromise(innerParams.preDeny(value, innerParams.validationMessage)));
      preDenyPromise.then(preDenyValue => {
        if (preDenyValue === falso) {
          instancia.hideLoading();
          handleAwaitingPromise(instancia);
        } demás {
          instancia.closePopup({
            isDenied: cierto,
            valor: typeof preDenyValue === 'indefinido' ? valor: preDenyValor
          });
        }
      }).catch(error$$1 => rechazoCon(instancia || indefinido, error$$1));
    } demás {
      instancia.closePopup({
        isDenied: cierto,
        valor
      });
    }
  };

  const exitoCon = (instancia, valor) => {
    instancia.closePopup({
      esConfirmado: cierto,
      valor
    });
  };

  const rechazarCon = (instancia, error$$1) => {
    instancia.rechazarPromise(error$$1);
  };

  const confirmar = (instancia, valor) => {
    const innerParams = privateProps.innerParams.get(instancia || indefinido);

    si (innerParams.showLoaderOnConfirm) {
      mostrarCargando();
    }

    si (innerParams.preConfirm) {
      instancia.resetValidationMessage();
      privateProps.awaitingPromise.set(instancia || indefinido, verdadero); // Marcar la instancia como en espera de una promesa para que los métodos de rechazo/resolver de su propia promesa no se destruyan hasta que se reciba el resultado de esta promesa de confirmación previa

      const preConfirmPromise = Promise.resolve().then(() => asPromise(innerParams.preConfirm(value, innerParams.validationMessage)));
      preConfirmPromise.then(preConfirmValue => {
        if (isVisible(getValidationMessage()) || preConfirmValue === false) {
          instancia.hideLoading();
          handleAwaitingPromise(instancia);
        } demás {
          exitoCon(instancia, tipo de preConfirmValue === 'indefinido' ? valor : preConfirmValue);
        }
      }).catch(error$$1 => rechazoCon(instancia || indefinido, error$$1));
    } demás {
      exitoCon(instancia, valor);
    }
  };

  const handlePopupClick = (instancia, domCache, descartarCon) => {
    const innerParams = privateProps.innerParams.get(instancia);

    if (innerParams.tostadas) {
      handleToastClick(instancia, domCache, descartarCon);
    } demás {
      // Ignora los eventos de clic que tenían el mouse hacia abajo en la ventana emergente pero el mouse hacia arriba en el contenedor
      // Esto puede suceder cuando el usuario arrastra un control deslizante
      manejarModalMousedown(domCache); // Ignorar los eventos de clic que tenían el mouse hacia abajo en el contenedor pero el mouse hacia arriba en la ventana emergente

      handleContainerMousedown(domCache);
      handleModalClick(instancia, domCache, descartarCon);
    }
  };

  const handleToastClick = (instancia, domCache, descartarCon) => {
    // Cerrar brindis por click interno
    domCache.popup.onclick = () => {
      const innerParams = privateProps.innerParams.get(instancia);

      if (innerParams && (isAnyButtonShown(innerParams) || innerParams.timer || innerParams.input)) {
        regreso;
      }

      descartar con (DismissReason.close);
    };
  };
  /**
   * @param {*} parámetros internos
   * @devoluciones {booleano}
   */


  const esCualquierBotónMostrado = parámetrosInteriores => {
    volver innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || ParámetrosInteriores.showCloseButton;
  };

  let ignoreOutsideClick = false;

  const handleModalMousedown = domCache => {
    domCache.popup.onmousedown = () => {
      domCache.container.onmouseup = función (e) {
        domCache.container.onmouseup = indefinido; // Solo verificamos si el objetivo del mouse arriba es el contenedor porque generalmente no lo hace
        // tiene otros hijos directos aparte de la ventana emergente

        if (e.objetivo === domCache.container) {
          ignoreOutsideClick = true;
        }
      };
    };
  };

  const handleContainerMousedown = domCache => {
    domCache.container.onmousedown = () => {
      domCache.popup.onmouseup = función (e) {
        domCache.popup.onmouseup = indefinido; // También necesitamos verificar si el objetivo mouseup es un elemento secundario de la ventana emergente

        if (e.objetivo === domCache.popup || domCache.popup.contains(e.objetivo)) {
          ignoreOutsideClick = true;
        }
      };
    };
  };

  const handleModalClick = (instancia, domCache, descartarCon) => {
    domCache.container.onclick = e => {
      const innerParams = privateProps.innerParams.get(instancia);

      if (ignorarHacer clic exterior) {
        ignoreOutsideClick = false;
        regreso;
      }

      if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {
        descartar con (DismissReason.backdrop);
      }
    };
  };

  /*
   * Función global para determinar si se muestra la ventana emergente SweetAlert2
   */

  const esVisible$1 = () => {
    volver esVisible(getPopup());
  };
  /*
   * Función global para hacer clic en el botón 'Confirmar'
   */

  const clickConfirm = () => getConfirmButton() && getConfirmButton().click();
  /*
   * Función global para hacer clic en el botón 'Denegar'
   */

  const clickDeny = () => getDenyButton() && getDenyButton().click();
  /*
   * Función global para hacer clic en el botón 'Cancelar'
   */

  const clickCancel = () => getCancelButton() && getCancelButton().click();

  const addKeydownHandler = (instancia, estado global, parámetros internos, descartar con) => {
    if (globalState.keydownTarget && globalState.keydownHandlerAdded) {
      globalState.keydownTarget.removeEventListener('keydown', globalState.keydownHandler, {
        captura: globalState.keydownListenerCapture
      });
      globalState.keydownHandlerAdded = falso;
    }

    if (!innerParams.toast) {
      globalState.keydownHandler = e => keydownHandler(instancia, e, descartarCon);

      globalState.keydownTarget = innerParams.keydownListenerCapture? ventana: getPopup();
      globalState.keydownListenerCapture = innerParams.keydownListenerCapture;
      globalState.keydownTarget.addEventListener('keydown', globalState.keydownHandler, {
        captura: globalState.keydownListenerCapture
      });
      globalState.keydownHandlerAdded = verdadero;
    }
  }; // Manejo del foco

  const setFocus = (parámetros internos, índice, incremento) => {
    const FocusableElements = getFocusableElements(); // busca elementos visibles y selecciona la siguiente coincidencia posible

    if (elementos enfocables.longitud) {
      índice = índice + incremento; // rollover al primer elemento

      if (índice === elementos enfocables.longitud) {
        índice = 0; // ir al último elemento
      } más si (índice === -1) {
        índice = elementos enfocables.longitud - 1;
      }

      devuelve FocusableElements[índice].focus();
    } // no hay elementos enfocables visibles, enfoca la ventana emergente


    getPopup().focus();
  };
  const arrowKeysNextButton = ['FlechaDerecha', 'FlechaAbajo'];
  const arrowKeysPreviousButton = ['Flecha hacia la izquierda', 'Flecha hacia arriba'];

  const keydownHandler = (instancia, e, descartarCon) => {
    const innerParams = privateProps.innerParams.get(instancia);

    if (!innerParams) {
      regreso; // Esta instancia ya ha sido destruida
    } // Ignorar keydown durante la composición de IME
    // https://developer.mozilla.org/en-US/docs/Web/API/Document/keydown_event#ignoring_keydown_durante_ime_composition
    // https://github.com/sweetalert2/sweetalert2/issues/720
    // https://github.com/sweetalert2/sweetalert2/issues/2406


    if (e.isComposing || e.keyCode === 229) {
      regreso;
    }

    si (innerParams.stopKeydownPropagation) {
      e.detener la propagación();
    } // INGRESAR


    if (e.key === 'Entrar') {
      handleEnter(instancia, e, parámetros internos);
    } // PESTAÑA
    más si (e.key === 'Tab') {
      handleTab(e, ParámetrosInteriores);
    } // FLECHAS - cambia el enfoque entre los botones
    else if ([...arrowKeysNextButton, ...arrowKeysPreviousButton].includes(e.key)) {
      handleArrows(e.key);
    } // ESC
    más si (e.key === 'Escape') {
      handleEsc(e, innerParams, descartarCon);
    }
  };

  const handleEnter = (instancia, e, parámetros internos) => {
    // https://github.com/sweetalert2/sweetalert2/issues/2386
    if (!callIfFunction(innerParams.allowEnterKey)) {
      regreso;
    }

    if (e.objetivo && instancia.getInput() && e.objetivo.outerHTML === instancia.getInput().outerHTML) {
      if (['área de texto', 'archivo'].includes(innerParams.input)) {
        regreso; // no envíe
      }

      hacer clic en Confirmar();
      e.preventDefault();
    }
  };

  const handleTab = (e, parámetros internos) => {
    const targetElement = e.objetivo;
    const FocusableElements = getFocusableElements();
    sea ​​btnIndex = -1;

    for (let i = 0; i <focusableElements.length; i++) {
      if (objetivoElement === elementos enfocables[i]) {
        btnÍndice = i;
        descanso;
      }
    } // Ciclo al siguiente botón


    if (!e.shiftKey) {
      setFocus(innerParams, btnIndex, 1);
    } // Ir al botón anterior
    demás {
      setFocus(innerParams, btnIndex, -1);
    }

    e.detener la propagación();
    e.preventDefault();
  };

  const handleArrows = tecla => {
    const confirmButton = getConfirmButton();
    const denyButton = getDenyButton();
    const cancelButton = getCancelButton();

    if (![confirmarBotón, denegarBotón, cancelarBotón].incluye(documento.elementoactivo)) {
      regreso;
    }

    const hermano = arrowKeysNextButton.includes(clave) ? 'siguienteElementoSibling' : 'anteriorElementoSibling';
    let buttonToFocus = document.activeElement;

    for (let i = 0; i < getActions().children.length; i++) {
      buttonToFocus = buttonToFocus[hermano];

      si (!buttonToFocus) {
        regreso;
      }

      if (isVisible(buttonToFocus) && buttonToFocus instancia de HTMLButtonElement) {
        descanso;
      }
    }

    if (instancia de buttonToFocus de HTMLButtonElement) {
      botónParaEnfocar.focus();
    }
  };

  const handleEsc = (e, parámetros internos, descartar con) => {
    si (callIfFunction(innerParams.allowEscapeKey)) {
      e.preventDefault();
      descartar con (DismissReason.esc);
    }
  };

  const isJqueryElement = elem => typeof elem === 'objeto' && elem.jquery;

  const isElement = elem => elem instancia de Elemento || esJqueryElement(elemento);

  const argsToParams = args => {
    parámetros constantes = {};

    if (tipo de argumentos[0] === 'objeto' && !isElement(argumentos[0])) {
      Object.assign(parámetros, argumentos[0]);
    } demás {
      ['título', 'html', 'icono'].forEach((nombre, índice) => {
        const arg = args[índice];

        if (tipo de argumento === 'cadena' || isElement(arg)) {
          parámetros[nombre] = arg;
        } más si (arg !== indefinido) {
          error("Tipo inesperado de ".concat(nombre, "! Se esperaba \"cadena\" o \"Elemento\", obtenido ").concat(typeof arg));
        }
      });
    }

    parámetros de retorno;
  };

  fuego función () {
    const Swal = esto; // eslint-disable-line @typescript-eslint/no-this-alias

    for (var _len = argumentos.longitud, args = new Array(_len), _key = 0; _key < _len; _key++) {
      argumentos[_clave] = argumentos[_clave];
    }

    devuelve nuevo Swal(...argumentos);
  }

  /**
   * Devuelve una versión extendida de `Swal` que contiene `params` por defecto.
   * Útil para reutilizar la configuración Swal.
   *
   * Por ejemplo:
   *
   * Antes:
   * const textPromptOptions = { entrada: 'texto', showCancelButton: verdadero }
   * const {value: firstName} = await Swal.fire({ ...textPromptOptions, title: '¿Cuál es tu nombre?' })
   * const {value: lastName} = await Swal.fire({ ...textPromptOptions, title: '¿Cuál es tu apellido?' })
   *
   * Después:
   * const TextPrompt = Swal.mixin({ entrada: 'texto', showCancelButton: verdadero })
   * const {value: firstName} = await TextPrompt('¿Cuál es su nombre?')
   * const {value: lastName} = await TextPrompt('¿Cuál es tu apellido?')
   *
   * @param mixinParams
   */
  función mixin(mixinParams) {
    class MixinSwal extiende este {
      _main(parámetros, prioridadMixinParams) {
        return super._main(params, Object.assign({}, mixinParams, priorityMixinParams));
      }

    }

    volver MixinSwal;
  }

  /**
   * Si se establece el parámetro `timer`, devuelve el número de milisegundos restantes del temporizador.
   * De lo contrario, devuelve indefinido.
   */

  const getTimerLeft = () => {
    volver globalState.timeout && globalState.timeout.getTimerLeft();
  };
  /**
   * Detener el temporizador. Devuelve el número de milisegundos restantes del temporizador.
   * Si el parámetro `timer` no está configurado, devuelve indefinido.
   */

  const stopTimer = () => {
    si (globalState.tiempo de espera) {
      detener la barra de progreso del temporizador ();
      devuelve globalState.timeout.stop();
    }
  };
  /**
   * Reanudar temporizador. Devuelve el número de milisegundos restantes del temporizador.
   * Si el parámetro `timer` no está configurado, devuelve indefinido.
   */

  const resumeTimer = () => {
    si (globalState.tiempo de espera) {
      constante restante = globalState.timeout.start();
      animateTimerProgressBar(restante);
      devolución restante;
    }
  };
  /**
   * Reanudar temporizador. Devuelve el número de milisegundos restantes del temporizador.
   * Si el parámetro `timer` no está configurado, devuelve indefinido.
   */

  const alternar temporizador = () => {
    const temporizador = globalState.timeout;
    devolver temporizador && (temporizador.ejecutando ? stopTimer() : resumeTimer());
  };
  /**
   * Aumentar el temporizador. Devuelve el número de milisegundos de un temporizador actualizado.
   * Si el parámetro `timer` no está configurado, devuelve indefinido.
   */

  const aumentarTiempo = n => {
    si (globalState.tiempo de espera) {
      constante restante = globalState.timeout.increase(n);
      animateTimerProgressBar(restante, verdadero);
      devolución restante;
    }
  };
  /**
   * Compruebe si el temporizador está funcionando. Devuelve verdadero si el temporizador se está ejecutando
   * o falso si el temporizador está en pausa o detenido.
   * Si el parámetro `timer` no está configurado, devuelve indefinido
   */

  const esTimerRunning = () => {
    volver globalState.timeout && globalState.timeout.isRunning();
  };

  let bodyClickListenerAdded = false;
  const manejadores de clics = {};
  función enlazarClickHandler() {
    let attr = argumentos.longitud > 0 && argumentos[0] !== indefinido ? argumentos [0]: 'plantilla-swal-datos';
    clickHandlers[atributo] = esto;

    if (!bodyClickListenerAdded) {
      document.body.addEventListener('clic', bodyClickListener);
      bodyClickListenerAdded = verdadero;
    }
  }

  const bodyClickListener = evento => {
    for (let el = evento.objetivo; el && el !== documento; el = el.parentNode) {
      para (const attr en clickHandlers) {
        plantilla const = el.getAttribute(attr);

        si (plantilla) {
          clickHandlers[atributo].fuego({
            plantilla
          });
          regreso;
        }
      }
    }
  };



  var staticMethods = /*#__PURE__*/Object.freeze({
    isValidParameter: esValidParameter,
    isUpdatableParameter: isUpdatableParameter,
    esDeprecatedParameter: esDeprecatedParameter,
    argsToParams: argsToParams,
    esVisible: esVisible$1,
    haga clic en Confirmar: haga clic en Confirmar,
    haga clic en Denegar: haga clic en Denegar,
    hacer clic en Cancelar: hacer clic en Cancelar,
    getContainer: getContainer,
    getPopup: getPopup,
    obtenerTítulo: obtenerTítulo,
    getHtmlContainer: getHtmlContainer,
    obtenerImagen: obtenerImagen,
    obtener icono: obtener icono,
    obtenerEtiquetaEntrada: obtenerEtiquetaEntrada,
    obtenerBotonCerrar: obtenerBotonCerrar,
    obtener acciones: obtener acciones,
    obtenerBotonConfirmar: obtenerBotonConfirmar,
    getDenyButton: getDenyButton,
    obtenerBotonCancelar: obtenerBotonCancelar,
    getLoader: getLoader,
    getFooter: obtenerPie de página,
    getTimerProgressBar: getTimerProgressBar,
    obtenerElementosEnfocables: obtenerElementosEnfocables,
    obtener mensaje de validación: obtener mensaje de validación,
    está cargando: está cargando,
    fuego fuego,
    mezclando: mezclando,
    mostrar cargando: mostrar cargando,
    enableLoading: showLoading,
    getTimerLeft: getTimerLeft,
    detener el temporizador: detener el temporizador,
    reanudar el temporizador: reanudar el temporizador,
    alternar temporizador: alternar temporizador,
    aumentarTemporizador: aumentarTemporizador,
    esTimerRunning: esTimerRunning,
    enlazarClickHandler: enlazarClickHandler
  });

  let instanciaActual;

  clase alerta dulce {
    constructor() {
      // Impedir la ejecución en Node env
      if (tipo de ventana === 'indefinido') {
        regreso;
      }

      instanciaActual = esto; // @ts-ignorar

      for (var _len = argumentos.longitud, args = new Array(_len), _key = 0; _key < _len; _key++) {
        argumentos[_clave] = argumentos[_clave];
      }

      const parámetros externos = Object.freeze(this.constructor.argsToParams(args));
      Objeto.defineProperties(esto, {
        parámetros: {
          valor: parámetros externos,
          escribible: falso,
          enumerable: cierto,
          configurable: verdadero
        }
      }); // @ts-ignorar

      const promesa = this._main(this.params);

      privateProps.promise.set(esto, promesa);
    }

    _main(parámetros de usuario) {
      let mixinParams = argumentos.longitud > 1 && argumentos[1] !== indefinido ? argumentos[1] : {};
      showWarningsForParams(Object.assign({}, mixinParams, userParams));

      if (estadoglobal.instanciaactual) {
        globalState.currentInstance._destroy();

        si (esModal()) {
          unsetAriaHidden();
        }
      }

      globalState.currentInstance = esto;
      const innerParams = prepareParams(userParams, mixinParams);
      setParameters(innerParams);
      Object.freeze(innerParams); // borrar el temporizador anterior

      si (globalState.tiempo de espera) {
        globalState.timeout.stop();
        eliminar globalState.tiempo de espera;
      } // borra el tiempo de espera del enfoque de restauración


      clearTimeout(globalState.restoreFocusTimeout);
      const domCache = populateDomCache(esto);
      renderizar (esto, parámetros internos);
      privateProps.innerParams.set(this, innerParams);
      return swalPromise(this, domCache, innerParams);
    } // `catch` no puede ser el nombre de una exportación de módulo, por lo que definimos nuestros métodos entonces disponibles aquí


    luego (al cumplir) {
      const promesa = privateProps.promise.get(esto);
      returnpromise.then(onFulfilled);
    }

    finalmente(porFinalmente) {
      const promesa = privateProps.promise.get(esto);
      volver promesa.finalmente(enFinalmente);
    }

  }

  const swalPromise = (instancia, domCache, parámetros internos) => {
    volver nueva Promesa((resolver, rechazar) => {
      // funciones para manejar todos los cierres/despidos
      const descartarCon = descartar => {
        instancia.closePopup({
          isDismissed: cierto,
          descartar
        });
      };

      privateMethods.swalPromiseResolve.set(instancia, resolución);
      privateMethods.swalPromiseReject.set(instancia, rechazo);

      domCache.confirmButton.onclick = () => handleConfirmButtonClick(instancia);

      domCache.denyButton.onclick = () => handleDenyButtonClick(instancia);

      domCache.cancelButton.onclick = () => handleCancelButtonClick(instancia, descartarCon);

      domCache.closeButton.onclick = () => descartarCon(DismissReason.close);

      handlePopupClick(instancia, domCache, descartarCon);
      addKeydownHandler(instancia, estado global, parámetros internos, descartar con);
      handleInputOptionsAndValue(instancia, parámetros internos);
      openPopup(innerParams);
      setupTimer(globalState, innerParams, dismissWith);
      initFocus(domCache, parámetros internos); // Desplazar el contenedor hacia arriba al abrirlo (#1247, #1946)

      establecerTiempo de espera(() => {
        domCache.container.scrollTop = 0;
      });
    });
  };

  const prepareParams = (userParams, mixinParams) => {
    const templateParams = getTemplateParams(userParams);
    const params = Object.assign({}, defaultParams, mixinParams, templateParams, userParams); // la precedencia se describe en #2131

    params.showClass = Object.assign({}, defaultParams.showClass, params.showClass);
    params.hideClass = Object.assign({}, defaultParams.hideClass, params.hideClass);
    parámetros de retorno;
  };

  const populateDomCache = instancia => {
    const domCache = {
      ventana emergente: getPopup(),
      contenedor: getContainer(),
      acciones: getActions(),
      Botón de Confirmación: obtener Botón de Confirmación(),
      botón denegar: getBotónDenegar(),
      botón cancelar: getCancelButton(),
      cargador: getLoader(),
      botóncerrar: getBotónCerrar(),
      mensaje de validación: obtener mensaje de validación (),
      Pasos de progreso: obtener Pasos de progreso ()
    };
    privateProps.domCache.set(instancia, domCache);
    volver domCache;
  };

  const setupTimer = (globalState$$1, innerParams, dismissWith) => {
    const timerProgressBar = getTimerProgressBar();
    ocultar (barra de progreso del temporizador);

    if (innerParams.timer) {
      globalState$$1.timeout = nuevo Temporizador(() => {
        descartar con ('temporizador');
        eliminar globalState$$1.tiempo de espera;
      }, ParámetrosInteriores.temporizador);

      if (innerParams.timerProgressBar) {
        mostrar (barra de progreso del temporizador);
        applyCustomClass(timerProgressBar, innerParams, 'timerProgressBar');
        establecerTiempo de espera(() => {
          if (globalState$$1.timeout && globalState$$1.timeout.running) {
            // el temporizador ya puede estar detenido o desarmado en este punto
            animateTimerProgressBar(innerParams.timer);
          }
        });
      }
    }
  };

  const initFocus = (domCache, parámetros internos) => {
    if (innerParams.tostadas) {
      regreso;
    }

    if (!callIfFunction(innerParams.allowEnterKey)) {
      devuelve el elemento borrosoActivo();
    }

    if (!focusButton(domCache, parámetros internos)) {
      setFocus(innerParams, -1, 1);
    }
  };

  const focusButton = (domCache, parámetros internos) => {
    if (innerParams.focusDeny && isVisible(domCache.denyButton)) {
      domCache.denyButton.focus();
      devolver verdadero;
    }

    if (innerParams.focusCancel && isVisible(domCache.cancelButton)) {
      domCache.cancelButton.focus();
      devolver verdadero;
    }

    if (innerParams.focusConfirm && isVisible(domCache.confirmButton)) {
      domCache.confirmButton.focus();
      devolver verdadero;
    }

    falso retorno;
  };

  const blurActiveElement = () => {
    if (document.activeElement instanceof HTMLElement && typeof document.activeElement.blur === 'function') {
      document.activeElement.blur();
    }
  }; // Assign instance methods from src/instanceMethods/*.js to prototype


  Object.assign(SweetAlert.prototype, instanceMethods); // Assign static methods from src/staticMethods/*.js to constructor

  Object.assign(SweetAlert, staticMethods); // Proxy to instance methods to constructor, for now, for backwards compatibility

  Object.keys(instanceMethods).forEach(key => {
    SweetAlert[key] = function () {
      if (currentInstance) {
        return currentInstance[key](...arguments);
      }
    };
  });
  SweetAlert.DismissReason = DismissReason;
  SweetAlert.version = '11.4.4';

  const Swal = SweetAlert; // @ts-ignore

  Swal.default = Swal;

  return Swal;

}));
if (typeof this !== 'undefined' && this.Sweetalert2){  this.swal = this.sweetAlert = this.Swal = this.SweetAlert = this.Sweetalert2}

"undefined"!=typeof document&&function(e,t){var n=e.createElement("style");if(e.getElementsByTagName("head")[0].appendChild(n),n.styleSheet)n.styleSheet.disabled||(n.styleSheet.cssText=t);else try{n.innerHTML=t}catch(e){n.innerText=t}}(document,".swal2-popup.swal2-toast{box-sizing:border-box;grid-column:1/4!important;grid-row:1/4!important;grid-template-columns:1fr 99fr 1fr;padding:1em;overflow-y:hidden;background:#fff;box-shadow:0 0 1px rgba(0,0,0,.075),0 1px 2px rgba(0,0,0,.075),1px 2px 4px rgba(0,0,0,.075),1px 3px 8px rgba(0,0,0,.075),2px 4px 16px rgba(0,0,0,.075);pointer-events:all}.swal2-popup.swal2-toast>*{grid-column:2}.swal2-popup.swal2-toast .swal2-title{margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-loading{justify-content:center}.swal2-popup.swal2-toast .swal2-input{height:2em;margin:.5em;font-size:1em}.swal2-popup.swal2-toast .swal2-validation-message{font-size:1em}.swal2-popup.swal2-toast .swal2-footer{margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-popup.swal2-toast .swal2-close{grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-popup.swal2-toast .swal2-html-container{margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-html-container:empty{padding:0}.swal2-popup.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-popup.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:700}.swal2-popup.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-popup.swal2-toast .swal2-actions{justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-popup.swal2-toast .swal2-styled{margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-popup.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;transform:rotate(45deg);border-radius:50%}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.8em;left:-.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-popup.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{-webkit-animation:swal2-toast-animate-success-line-tip .75s;animation:swal2-toast-animate-success-line-tip .75s}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{-webkit-animation:swal2-toast-animate-success-line-long .75s;animation:swal2-toast-animate-success-line-long .75s}.swal2-popup.swal2-toast.swal2-show{-webkit-animation:swal2-toast-show .5s;animation:swal2-toast-show .5s}.swal2-popup.swal2-toast.swal2-hide{-webkit-animation:swal2-toast-hide .1s forwards;animation:swal2-toast-hide .1s forwards}.swal2-container{display:grid;position:fixed;z-index:1060;top:0;right:0;bottom:0;left:0;box-sizing:border-box;grid-template-areas:\"top-start     top            top-end\" \"center-start  center         center-end\" \"bottom-start  bottom-center  bottom-end\";grid-template-rows:minmax(-webkit-min-content,auto) minmax(-webkit-min-content,auto) minmax(-webkit-min-content,auto);grid-template-rows:minmax(min-content,auto) minmax(min-content,auto) minmax(min-content,auto);height:100%;padding:.625em;overflow-x:hidden;transition:background-color .1s;-webkit-overflow-scrolling:touch}.swal2-container.swal2-backdrop-show,.swal2-container.swal2-noanimation{background:rgba(0,0,0,.4)}.swal2-container.swal2-backdrop-hide{background:0 0!important}.swal2-container.swal2-bottom-start,.swal2-container.swal2-center-start,.swal2-container.swal2-top-start{grid-template-columns:minmax(0,1fr) auto auto}.swal2-container.swal2-bottom,.swal2-container.swal2-center,.swal2-container.swal2-top{grid-template-columns:auto minmax(0,1fr) auto}.swal2-container.swal2-bottom-end,.swal2-container.swal2-center-end,.swal2-container.swal2-top-end{grid-template-columns:auto auto minmax(0,1fr)}.swal2-container.swal2-top-start>.swal2-popup{align-self:start}.swal2-container.swal2-top>.swal2-popup{grid-column:2;align-self:start;justify-self:center}.swal2-container.swal2-top-end>.swal2-popup,.swal2-container.swal2-top-right>.swal2-popup{grid-column:3;align-self:start;justify-self:end}.swal2-container.swal2-center-left>.swal2-popup,.swal2-container.swal2-center-start>.swal2-popup{grid-row:2;align-self:center}.swal2-container.swal2-center>.swal2-popup{grid-column:2;grid-row:2;align-self:center;justify-self:center}.swal2-container.swal2-center-end>.swal2-popup,.swal2-container.swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;align-self:center;justify-self:end}.swal2-container.swal2-bottom-left>.swal2-popup,.swal2-container.swal2-bottom-start>.swal2-popup{grid-column:1;grid-row:3;align-self:end}.swal2-container.swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;justify-self:center;align-self:end}.swal2-container.swal2-bottom-end>.swal2-popup,.swal2-container.swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;align-self:end;justify-self:end}.swal2-container.swal2-grow-fullscreen>.swal2-popup,.swal2-container.swal2-grow-row>.swal2-popup{grid-column:1/4;width:100%}.swal2-container.swal2-grow-column>.swal2-popup,.swal2-container.swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}.swal2-container.swal2-no-transition{transition:none!important}.swal2-popup{display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0,100%);width:32em;max-width:100%;padding:0 0 1.25em;border:none;border-radius:5px;background:#fff;color:#545454;font-family:inherit;font-size:1rem}.swal2-popup:focus{outline:0}.swal2-popup.swal2-loading{overflow-y:hidden}.swal2-title{position:relative;max-width:100%;margin:0;padding:.8em 1em 0;color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word}.swal2-actions{display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:center;width:auto;margin:1.25em auto 0;padding:0}.swal2-actions:not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}.swal2-actions:not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0,0,0,.1),rgba(0,0,0,.1))}.swal2-actions:not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2))}.swal2-loader{display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;-webkit-animation:swal2-rotate-loading 1.5s linear 0s infinite normal;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 transparent #2778c4 transparent}.swal2-styled{margin:.3125em;padding:.625em 1.1em;transition:box-shadow .1s;box-shadow:0 0 0 3px transparent;font-weight:500}.swal2-styled:not([disabled]){cursor:pointer}.swal2-styled.swal2-confirm{border:0;border-radius:.25em;background:initial;background-color:#7066e0;color:#fff;font-size:1em}.swal2-styled.swal2-confirm:focus{box-shadow:0 0 0 3px rgba(112,102,224,.5)}.swal2-styled.swal2-deny{border:0;border-radius:.25em;background:initial;background-color:#dc3741;color:#fff;font-size:1em}.swal2-styled.swal2-deny:focus{box-shadow:0 0 0 3px rgba(220,55,65,.5)}.swal2-styled.swal2-cancel{border:0;border-radius:.25em;background:initial;background-color:#6e7881;color:#fff;font-size:1em}.swal2-styled.swal2-cancel:focus{box-shadow:0 0 0 3px rgba(110,120,129,.5)}.swal2-styled.swal2-default-outline:focus{box-shadow:0 0 0 3px rgba(100,150,200,.5)}.swal2-styled:focus{outline:0}.swal2-styled::-moz-focus-inner{border:0}.swal2-footer{justify-content:center;margin:1em 0 0;padding:1em 1em 0;border-top:1px solid #eee;color:inherit;font-size:1em}.swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto!important;overflow:hidden;border-bottom-right-radius:5px;border-bottom-left-radius:5px}.swal2-timer-progress-bar{width:100%;height:.25em;background:rgba(0,0,0,.2)}.swal2-image{max-width:100%;margin:2em auto 1em}.swal2-close{z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:color .1s,box-shadow .1s;border:none;border-radius:5px;background:0 0;color:#ccc;font-family:serif;font-family:monospace;font-size:2.5em;cursor:pointer;justify-self:end}.swal2-close:hover{transform:none;background:0 0;color:#f27474}.swal2-close:focus{outline:0;box-shadow:inset 0 0 0 3px rgba(100,150,200,.5)}.swal2-close::-moz-focus-inner{border:0}.swal2-html-container{z-index:1;justify-content:center;margin:1em 1.6em .3em;padding:0;overflow:auto;color:inherit;font-size:1.125em;font-weight:400;line-height:normal;text-align:center;word-wrap:break-word;word-break:break-word}.swal2-checkbox,.swal2-file,.swal2-input,.swal2-radio,.swal2-select,.swal2-textarea{margin:1em 2em 3px}.swal2-file,.swal2-input,.swal2-textarea{box-sizing:border-box;width:auto;transition:border-color .1s,box-shadow .1s;border:1px solid #d9d9d9;border-radius:.1875em;background:inherit;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px transparent;color:inherit;font-size:1.125em}.swal2-file.swal2-inputerror,.swal2-input.swal2-inputerror,.swal2-textarea.swal2-inputerror{border-color:#f27474!important;box-shadow:0 0 2px #f27474!important}.swal2-file:focus,.swal2-input:focus,.swal2-textarea:focus{border:1px solid #b4dbed;outline:0;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(100,150,200,.5)}.swal2-file::-moz-placeholder,.swal2-input::-moz-placeholder,.swal2-textarea::-moz-placeholder{color:#ccc}.swal2-file:-ms-input-placeholder,.swal2-input:-ms-input-placeholder,.swal2-textarea:-ms-input-placeholder{color:#ccc}.swal2-file::placeholder,.swal2-input::placeholder,.swal2-textarea::placeholder{color:#ccc}.swal2-range{margin:1em 2em 3px;background:#fff}.swal2-range input{width:80%}.swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}.swal2-range input,.swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}.swal2-input{height:2.625em;padding:0 .75em}.swal2-file{width:75%;margin-right:auto;margin-left:auto;background:inherit;font-size:1.125em}.swal2-textarea{height:6.75em;padding:.75em}.swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:inherit;color:inherit;font-size:1.125em}.swal2-checkbox,.swal2-radio{align-items:center;justify-content:center;background:#fff;color:inherit}.swal2-checkbox label,.swal2-radio label{margin:0 .6em;font-size:1.125em}.swal2-checkbox input,.swal2-radio input{flex-shrink:0;margin:0 .4em}.swal2-input-label{display:flex;justify-content:center;margin:1em auto 0}.swal2-validation-message{align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:#f0f0f0;color:#666;font-size:1em;font-weight:300}.swal2-validation-message::before{content:\"!\";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}.swal2-icon{position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;border:.25em solid transparent;border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}.swal2-icon.swal2-error{border-color:#f27474;color:#f27474}.swal2-icon.swal2-error .swal2-x-mark{position:relative;flex-grow:1}.swal2-icon.swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}.swal2-icon.swal2-error.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-error.swal2-icon-show .swal2-x-mark{-webkit-animation:swal2-animate-error-x-mark .5s;animation:swal2-animate-error-x-mark .5s}.swal2-icon.swal2-warning{border-color:#facea8;color:#f8bb86}.swal2-icon.swal2-warning.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-warning.swal2-icon-show .swal2-icon-content{-webkit-animation:swal2-animate-i-mark .5s;animation:swal2-animate-i-mark .5s}.swal2-icon.swal2-info{border-color:#9de0f6;color:#3fc3ee}.swal2-icon.swal2-info.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-info.swal2-icon-show .swal2-icon-content{-webkit-animation:swal2-animate-i-mark .8s;animation:swal2-animate-i-mark .8s}.swal2-icon.swal2-question{border-color:#c9dae1;color:#87adbd}.swal2-icon.swal2-question.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-question.swal2-icon-show .swal2-icon-content{-webkit-animation:swal2-animate-question-mark .8s;animation:swal2-animate-question-mark .8s}.swal2-icon.swal2-success{border-color:#a5dc86;color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;transform:rotate(45deg);border-radius:50%}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}.swal2-icon.swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-.25em;left:-.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}.swal2-icon.swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}.swal2-icon.swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}.swal2-icon.swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-tip{-webkit-animation:swal2-animate-success-line-tip .75s;animation:swal2-animate-success-line-tip .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-long{-webkit-animation:swal2-animate-success-line-long .75s;animation:swal2-animate-success-line-long .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-circular-line-right{-webkit-animation:swal2-rotate-success-circular-line 4.25s ease-in;animation:swal2-rotate-success-circular-line 4.25s ease-in}.swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:inherit;font-weight:600}.swal2-progress-steps li{display:inline-block;position:relative}.swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:#add8e6;color:#fff}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:#add8e6}.swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}[class^=swal2]{-webkit-tap-highlight-color:transparent}.swal2-show{-webkit-animation:swal2-show .3s;animation:swal2-show .3s}.swal2-hide{-webkit-animation:swal2-hide .15s forwards;animation:swal2-hide .15s forwards}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}@-webkit-keyframes swal2-toast-show{0%{transform:translateY(-.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0)}}@keyframes swal2-toast-show{0%{transform:translateY(-.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0)}}@-webkit-keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@-webkit-keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@-webkit-keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@-webkit-keyframes swal2-show{0%{transform:scale(.7)}45%{transform:scale(1.05)}80%{transform:scale(.95)}100%{transform:scale(1)}}@keyframes swal2-show{0%{transform:scale(.7)}45%{transform:scale(1.05)}80%{transform:scale(.95)}100%{transform:scale(1)}}@-webkit-keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(.5);opacity:0}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(.5);opacity:0}}@-webkit-keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@-webkit-keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@-webkit-keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@-webkit-keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(.4);opacity:0}50%{margin-top:1.625em;transform:scale(.4);opacity:0}80%{margin-top:-.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(.4);opacity:0}50%{margin-top:1.625em;transform:scale(.4);opacity:0}80%{margin-top:-.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@-webkit-keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0);opacity:1}}@-webkit-keyframes swal2-rotate-loading{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes swal2-rotate-loading{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@-webkit-keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@-webkit-keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto!important}body.swal2-no-backdrop .swal2-container{background-color:transparent!important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px rgba(0,0,0,.4)}@media print{body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow-y:scroll!important}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown) .swal2-container{position:static!important}}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:transparent;pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{top:0;right:auto;bottom:auto;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{top:0;right:0;bottom:auto;left:auto}body.swal2-toast-shown .swal2-container.swal2-top-left,body.swal2-toast-shown .swal2-container.swal2-top-start{top:0;right:auto;bottom:auto;left:0}body.swal2-toast-shown .swal2-container.swal2-center-left,body.swal2-toast-shown .swal2-container.swal2-center-start{top:50%;right:auto;bottom:auto;left:0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{top:50%;right:auto;bottom:auto;left:50%;transform:translate(-50%,-50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{top:50%;right:0;bottom:auto;left:auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-left,body.swal2-toast-shown .swal2-container.swal2-bottom-start{top:auto;right:auto;bottom:0;left:0}body.swal2-toast-shown .swal2-container.swal2-bottom{top:auto;right:auto;bottom:0;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{top:auto;right:0;bottom:0;left:auto}");